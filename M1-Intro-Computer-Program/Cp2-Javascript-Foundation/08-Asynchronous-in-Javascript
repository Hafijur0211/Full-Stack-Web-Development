Asynchronous in JavaScript
Session Flow (5 minutes read)
Learning Objective (5 minutes read)
Introduction
Theme
Primary Goals
Asynchronous in JavaScript (120 minutes read)
JavaScript Event Loop
JavaScript single-threaded model
Callbacks in JavaScript
Do it yourself
JavaScript setTimeout()
Example 1: Write a program to display a Text Once After 3 Second
Example 2: Display Time Every 3 Second
JavaScript clearTimeout()
Example 3: To use clearTimeout() Method
Activity
JavaScript setInterval()
Example 4: To display a Text Once Every 1 Second
JavaScript clearInterval()
Example 5: Use clearInterval() Method
Explore Further
Summary (10 minutes read)
What did we learn?
Shortcomings & Challenges
Best Practices
Enhance Your Knowledge


Learning Objective
Introduction
Asynchronous programming in JavaScript allows you to run multiple tasks simultaneously without blocking the main thread and ensures fast and efficient execution of code.

Duration: 2 Hours

Focus: JavaScript loops and various methods such as - SetTimeOut() and SetInterval()

Prerequisites: VS code IDE with nodeJS installed

Theme
The JavaScript engine uses an event loop to efficiently manage multiple tasks in a web application. The event loop is like a never-ending loop that constantly checks the message queue for any new tasks that need to be executed, such as user interactions, network requests, timers, or any other actions. As soon as a task is added to the message queue, the event loop picks it up and executes it, and once it's completed, the event loop goes back to recheck the message queue for any new tasks.

The event loop in JavaScript ensures that the web application runs smoothly and efficiently, allowing for a seamless user experience. It acts like a chef in a restaurant who must manage multiple tasks at once, such as preparing different dishes for multiple customers and, monitoring the oven, plating the finished dishes. Just like the chef, the event loop must constantly check for new tasks and execute them as efficiently as possible.

Primary Goals
Understand SetTimeout() and SetInterval() methods. Make sure to understand how to use them, as they are commonly used in JavaScript programming.
Learn how the event loop works and how it manages the execution of asynchronous code.


Asynchronous in JavaScript
Samantha was a software developer who had just started working on a new project. She was excited to be working with JavaScript. Still, she quickly realized that she would need to learn about asynchronous programming if she was going to build a responsive and fast application.

At first, Samantha found asynchronous programming to be challenging. She was used to writing code that executed linearly, from top to bottom. But with asynchronous programming, she had to deal with code that was executed out of order and callbacks that fired at unpredictable times.

However, she was determined to learn, so she dove into the topic headfirst. She started by learning about callbacks, promises, and async/await. She also learned about the event loop, which was responsible for managing the execution of asynchronous code in JavaScript.

She discovered that asynchronous programming could make her application more responsive and faster. By using callbacks and promises, she could avoid blocking the main thread of the application, which could cause the application to freeze or become unresponsive.



JavaScript Event Loop
JavaScript single-threaded model
A single-threaded programming language is JavaScript. JavaScript can only perform one action at a time, according to this.

A script is run by the JavaScript engine starting at the top of the file and working its way down. In the execution phase, it establishes the execution contexts and pushes and pops functions onto and off of the call stack.

When a function takes too long to complete, the web page hangs, making it impossible for you to interact with the browser.

A blocking function is one that takes a long time to complete. Theoretically, a blocking feature prevents all website interactions, including mouse clicks.

An API call from a distant server illustrates a blocking function.

The following illustration simulates a blocking function using a huge loop:

function task(message) {
// emulate time consuming tasklet n = 10000;
    while (n > 0){
        n--;
    }
    console.log(message);
}

console.log('Start script...');
task('Download a file.');
console.log('Done!');
Code language: JavaScript (javascript)
In this example, the function "task()" contains a large "[while] loop that simulates a time-consuming activity. The blocking function "task()" is used.

Depending on how quickly the machine is running, the script hangs for a little while and outputs the following:

Start script...
Download a file.
Done!
The JavaScript engine executes the script by placing the first call, "console.log( )" at the top of the call stack. The "task()" function is then executed after being positioned at the top of the call stack.

Nevertheless, the 'task()' function won't finish immediately. The notification "Download a file." will therefore appear shortly. The JavaScript engine removes the completed "task()" function from the call stack after it has finished.

The JavaScript engine makes the final call to the “console.log('Done!')” function, which is subsequently executed.


Callbacks in JavaScript
Normally, blocking functions are placed in callback functions for subsequent execution to avoid interfering with other processes. For instance:

console.log('Start script...');

setTimeout(() => {
    task('Download a file.');
}, 1000);

console.log('Done!');
Code language: JavaScript (javascript)
You'll see the messages "Start script..." and "Done!" right away in this case. You will then see the notice "Download a file" after that.

Here is the result:

Start script...
Done!
Download a file.
The JavaScript engine can only perform one task at once, as was already described. To be more specific, the JavaScript runtime can only perform one action at once.

The JavaScript engine is only one of the parts of the web browser.

The web browser can perform these tasks simultaneously and asynchronously when you use the setTimeout() function, send a fetch request, or click a button.

Fetch requests, DOM events, and setTimeout() are all a part of the web browser's Web APIs.

In our example, the JavaScript engine calls the setTimeout() method, which the Web API inserts on the call stack and sets to expire in one second.




Then JavaScript engine place the task() function is into a queue called a callback queue or a task queue:


The callback queue and the call stack are both continuously monitored by the event loop, which runs in the background.



The next function from the callback queue is added to the call stack if the call stack is not empty. If it is not empty, the event loop waits until it is. Nothing happens if the callback queue is empty:


See another example:

console.log('Hi!');

setTimeout(() => {
    console.log('Execute immediately.');
}, 0);

console.log('Bye!');

Code language: JavaScript (javascript)
The message "Execute instantly." should come before the message "Bye!" in this example because the timeout is zero seconds. But that isn't how it operates.

Once the call stack is devoid of any functions, the JavaScript engine proceeds to execute the next function call that had been added to the callback queue. In other words, it is executed by the JavaScript engine after "console.log('Bye!')".

console.log('Execute immediately.');
Code language: JavaScript (javascript)
Here’s the output:

Hi!
Bye!
Execute immediately.
The following picture illustrates JavaScript runtime, Web API, Call stack, and Event loop:


Note: In order to achieve concurrency, the call stack and callback queue duties are coordinated by the JavaScript event loop, which is a continuously running process.

There are two ways to run programs at predetermined intervals. As follows:

setInterval()
setTimeout()


Do it yourself
Fill in the blanks:

When a function takes too long to complete, the web page ____ (slows down/crashes/freezes), making it impossible for you to interact with the browser. 
Normally, blocking functions are placed in _________ (synchronous callbacks/asynchronous callbacks/higher-order functions)for subsequent execution to avoid interfering with other processes. 
The JavaScript engine can only perform one task at once, but the web browser can perform these tasks _______ & ___________ (sequentially/simultaneously/ concurrently/randomly) when you use the setTimeout() function, send a fetch request, or click a button. 
Solution
freezes
asynchronous callbacks
Simultaneously, concurrently


JavaScript setTimeout()
After the amount of time that is specified, the "setTimeout()" method runs a block of code. A single instance of the method's code is run.



JavaScript's standard setTimeout syntax is:

setTimeout(function, milliseconds);
Its specifications are:

"function" refers to a function that contains a block of code - "milliseconds" refers to how long it takes for the function to execute.
A positive integer called a intervalID is what the "setTimeout()" method delivers.
Example 1: Write a program to display a Text Once After 3 Second
// display a text using the setTimeout method
function greet() 
{
    console.log('This will appear next');
}

setTimeout(function() {
  console.log("This message appears after 3 seconds");
}, 3000);
Output

This message appears after 3 secondsHello world
The "setTimeout()" method in the aforementioned software invokes the "greet()" function after 3000 milliseconds (3 second).

As a result, after 3 seconds the application only displays the text Hello world once.

Note: If you wish to execute a block of code only once after a certain amount of time, use the'setTimeout()' method. For instance, after the predetermined amount of time, showing the user a message.

Example 2: Display Time Every 3 Second
// program in javascript to display time every 3 seconds
function displayTime() {
  var currentTime = new Date();
  var hours = currentTime.getHours();
  var minutes = currentTime.getMinutes();
  var seconds = currentTime.getSeconds();
  var timeString = hours + ":" + minutes + ":" + seconds;
  console.log(timeString);
}

setInterval(displayTime, 3000);
Output

12:36:51
12:36:54
12:36:57
12:37:0
12:37:3
12:37:6
12:37:10
..................
The application mentioned above updates the time every 3 seconds.

After the time period (in this case, 3 seconds), the "setTimeout()" method only calls the procedure once.

But because the function in the aforementioned program is calling itself, it updates the time every 3 seconds.



This program is perpetual (until the memory runs out).

Note: It's preferable to use the 'setInterval()' method if you need to run a function more than once. Later on in this lecture, it will be discussed.

JavaScript clearTimeout()
The above example demonstrates how the program executes a block of code after a specific duration has elapsed. The "clearTimeout()" method can be used to halt this function call.

The 'clearTimeout()' method's syntax is as follows:

clearTimeout(intervalID);
The value returned by the setTimeout()method is assigned to the intervalID
variable here.

Example 3: To use clearTimeout() Method
// program in javascript to stop the setTimeout() method

let count = 0;

// function creation
function increaseCount(){

    // increasing the count by 1
    count += 1;
    console.log(count)
}

let id = setInterval(increaseCount, 3000);

// clearInterval
clearInterval(id);
console.log('setInterval is stopped.');
Output

setTimeout is stopped.
The 'setTimeout()' method is used in the application above to increase the value of the count after 3 seconds. The function call of the "setTimeout()" method is stopped by the "clearTimeout()" method. The count value is, therefore, not raised.

Note: If you need to stop the the'setTimeout()' method call before it takes effect, you typically use the 'clearTimeout()' function.


It is possible to provide extra arguments to the setTimeout() method. The syntax is 

setTimeout(function, delay, arg1, arg2, ...);
In this syntax, the first parameter is the function that will be executed after the specified delay. The second parameter is the delay time in milliseconds.

Any additional parameters after the delay time will be passed to the function as arguments. These arguments can be accessed inside the function using the arguments object.



For example,

// program to display a name
function sayHello(name, message) {
  console.log(`Hello, ${name}! ${message}`);
}

setTimeout(sayHello, 3000, "John", "How are you?");
Output

Hello, John! How are you?
In this example, the sayHello() function is called after a 3-second delay with two additional arguments: "John" and "How are you?". The function will output the message "Hello, John! How are you?" to the console.



Activity
True or False:

The setTimeout() method executes a block of code after a specific amount of time. 
The syntax for setTimeout() is setTimeout(function, seconds). 
The value returned by the setTimeout() method is a positive integer called intervalID . 
To run a block of code only once after a certain amount of time, use the setInterval() method.
Solution
True
False
True
False


JavaScript setInterval()
At each specified timing event, the "setInterval()" method repeats a code block.

JavaScript's standard setInterval syntax is:

setInterval(function, milliseconds);
Its specifications are:

"function" refers to a function that contains a block of code - "milliseconds" refers to the amount of time between the function's executions
A positive integer called a intervalID is what the "setInterval()" method returns.
Example 4: To display a Text Once Every 1 Second
// program in JavaScript to display a text using setInterval method

function greet() {
    console.log('Hello world');
}

setInterval(greet, 1000);


Output

Hello world
Hello world
Hello world
Hello world
Hello world
....
The "setInterval()" method in the programme above invokes the "greet()" function once every 1000 milliseconds (1 second).

The sentence Hello world is thus displayed by the software once every 1 second.

Note: If you need to execute a block of code multiple times, such as displaying a message at regular intervals, the setInterval() method can be quite helpful.

JavaScript clearInterval()
As you can see from the sample above, the program runs a block of code every predetermined amount of time. The "clearInterval()" method can be used to halt this function call.

clearInterval(intervalID);
In JavaScript, the return value of the setInterval() method is assigned to a variable called intervalID.

Example 5: Use clearInterval() Method
// program in JavaScript to stop the setInterval() method after five times

let count = 0;

function displayCount() {
  count++;
  console.log(`Count: ${count}`);
  if (count === 5) {
    clearInterval(intervalID);
    console.log("Interval stopped.");
  }
}

let intervalID = setInterval(displayCount, 1000);


Output

Count: 1
Count: 2
Count: 3
Count: 4
Count: 5
Interval stopped.
This program defines a displayCount function that increments a count variable and outputs it to the console. In this program, the setInterval() method is utilized to invoke the displayCount() function every second (1000 milliseconds), and the resulting interval ID is assigned to the intervalID variable.

When the count variable reaches 5, the clearInterval() function is called with the intervalID variable to stop the interval. The program then logs a message to the console to indicate that the interval has been stopped.

When you run this program, it will output the count to the console every second and stop the interval after the count reaches 5. You can customize the displayCount function to do something else or change the interval time to suit your needs.



Moreover, you can supply more arguments to the setInterval() method. As for the syntax:

setInterval(function, delay, arg1, arg2, ...);
The first parameter is the function that will be called at every specified delay. The second parameter is the delay time in milliseconds.

You can pass additional arguments after the delay time, which will be passed to the function as arguments. These arguments can be accessed inside the function using the arguments object.



For example,

// program to display name
function greet(name, message) {
  console.log(`Hello, ${name}! ${message}`);
}

setInterval(greet, 1000, "John", "How are you?");
Output

Hello John Doe
Hello John Doe
Hello John Doe
....
John and Doe are two parameters supplied to the setInterval() method in the application above. The function (in this case, greet()) that is defined inside the setInterval() method will receive these two parameters as arguments.



Explore Further
Uncover and unlock new insights as you dive into the captivating content found in the provided link.

Microtasks and Macrotasks: https://blog.bitsrc.io/microtask-and-macrotask-a-hands-on-approach-5d77050e2168



Tackle these questions head-on!

True or False:

The task queue processes exactly one macro task and all microtasks in each event loop cycle.
The setTimeout function enqueues a microtask in the microtask queue.
Microtasks can enqueue macro tasks within the same event loop cycle.
The event loop ensures that the UI remains responsive by processing micro tasks before macro tasks.
The event loop can lead to an unresponsive UI if the microtask queue becomes too large.
1. All microtasks are processed before any new macro tasks are taken from the task queue.
Answers
False
False
True
True
True
True


Callbacks were the traditional way of handling asynchronous code in JavaScript, but they can lead to callback hell and difficult-to-read code. According to a survey of over 20,000 JavaScript developers, 63.5% reported using callbacks, but only 15.3% said they preferred them.


Summary
What did we learn?
In JavaScript, only one task can be processed at a time since it's a single-threaded programming language. To handle multiple tasks, it uses an event loop mechanism that schedules and executes tasks one at a time in a sequential manner. 
Understanding the single-threaded nature of JavaScript is essential for writing efficient and scalable code that can run smoothly in this environment.
The JavaScript event loop is a mechanism that allows the single-threaded language to handle multiple tasks by scheduling and executing them one by one in a sequential manner. 
The event loop continuously checks the message queue for tasks waiting to be processed and executes them. It's crucial for handling asynchronous operations and enables efficient handling of multiple tasks in a single-threaded environment. Understanding the event loop is essential for writing efficient and performant JavaScript code.
setTimeout() is a JavaScript function that schedules a task to run after a specified amount of time has passed. The syntax is setTimeout(function, milliseconds), where the function
 is the code to be executed and milliseconds is the amount of time to wait before executing the code.
 setTimeout() is often used in web development for tasks such as updating page content, showing notifications, and more. It is non-blocking, meaning it runs in the background while the JavaScript engine executes other code.
setInterval() is a JavaScript function that allows you to run a function or code block repeatedly at a specified interval. The syntax is setInterval(function, milliseconds), where a function is a code to be executed repeatedly, and milliseconds is the time interval between each execution.
setInterval() is often used in web development for tasks such as updating page content, animating elements, and checking for new data. It is non-blocking, meaning it runs in the background while the JavaScript engine executes other code. The actual interval may vary slightly depending on performance and the amount of code being executed, so it's a good practice to use setTimeout() with a dynamically calculated interval.
clearInterval() is a JavaScript function that stops a repeating function scheduled with setInterval(). The syntax is clearInterval(intervalId), where intervalId is the value returned by setInterval(). It is important to clear intervals when they are no longer needed to prevent memory leaks and improve performance.
Shortcomings & Challenges
Asynchronous programming can be challenging to understand and debug, especially for developers who are new to the concept. Understanding the flow of code execution, callbacks, and promises can be challenging, leading to mistakes and bugs.
When using a large number of nested callbacks, it can become challenging to understand the structure of the code and the order of events. This is often called "Callback Hell" and can lead to unmaintainable code.
Error handling can be difficult when using asynchronous programming, as errors that occur in asynchronous code can be challenging to catch and diagnose.
Not all browsers support all the features of asynchronous programming in JavaScript. This can lead to compatibility issues and require additional code to ensure that the code works on all browsers.
Best Practices
Promises are a powerful tool for managing asynchronous code and provide a more structured way to handle callbacks and errors.
Minimize the use of nested callbacks and use Promises, async/await, or modular code to make the code more readable and maintainable.
async/await is a modern approach to asynchronous programming in JavaScript and provides a more intuitive and readable way to handle asynchronous code.
Blocking code can slow down the performance of your application and make it unresponsive. Make sure to perform time-consuming operations asynchronously to keep the UI responsive.
setTimeout() and setInterval() are powerful tools for scheduling asynchronous code, but make sure to use them wisely to avoid memory leaks and other performance issues.
Enhance Your Knowledge
JavaScript Asynchronous Programming and Callbacks
Synchronous vs Asynchronous JavaScript
