Functions in JavaScript - Advanced
Session Flow (5 minutes read)
Learning Objective (5 minutes read)
Introduction
Theme
Primary Goals
Functions in JavaScript - II (120 minutes read)
Helper Functions
Benefits of using a Function
Function Expressions
Do it yourself
Types of Functions in JavaScript
Arrow Function
Concise Body Arrow Function
Anonymous Function
Function Execution
Activity 1
JavaScript Hoisting 
Variable Hoisting
Function Hoisting
Activity 2
Explore Further
Summary (10 minutes read)
What did we learn?
Shortcomings & Challenges
Best Practices
Enhance Your Knowledge


Learning Objective
Introduction
Advanced JavaScript functions provide a more powerful and flexible way to write code by utilizing features such as helper functions, function expressions, function execution, and JavaScript hoisting. They allow developers to create modular and reusable code and handle complex scenarios such as asynchronous execution and function composition.

Duration: 2 Hours

Focus: Helper Functions, Function Expressions, Types of Functions in JavaScript, Function execution, and JavaScript Hoisting

Prerequisites: Basics of JavaScript Functions

Theme
Let's consider a fictional e-commerce company called "Shopify" that needs a shopping cart functionality for its website. We can use advanced JavaScript function concepts like helper functions, function expressions, and hoisting to implement this functionality.

We might use helper functions to perform common tasks like adding or removing items from the cart, calculating the total cost, and validating the items added to the cart. These functions can be called by a main function called updateCart.

We can use function expressions to define the helper functions since they only need to be defined within the scope of the updateCart function. This also allows us to use function execution to call the appropriate helper function based on the action parameter passed into the updateCart function.

JavaScript hoisting comes into play when we use function declarations or variable declarations. When a function or variable is declared with the var keyword, it is hoisted to the top of the function or global scope. This allows us to use the function or variable before it is declared in the code. However, this only applies to declarations, not function expressions or let/const variable declarations.

Primary Goals
Learn how to create reusable functions that perform specific tasks and can be called from other functions to simplify code.
Understand how functions are executed in JavaScript and how to pass arguments to functions.
Learn how JavaScript hoists variable and function declarations to the top of their respective scopes.
Understand the difference between function declarations and function expressions and how to use function expressions to create anonymous functions and closures.


Functions in JavaScript - II
Karen had been working as a web developer for several years, and she had become quite proficient in JavaScript. She had built many applications and websites over the years but always looked for ways to improve her skills.

One day, she came across helper functions in JavaScript. She had heard of helper functions before but had never explored the concept in depth. Intrigued, she decided to dive in and learn more.

She created a simple helper function to take a string and capitalize the first letter. She used this function throughout her application, saving her a lot of time and effort.

As she continued to work with helper functions, she discovered that there were many different types of functions in JavaScript. She learned about anonymous, arrow, and higher-order functions, among others.

Helper Functions
Helper functions in JavaScript are tools for dissecting big issues into smaller, easier-to-manage chunks. They can be called from other functions or portions of code and are created to carry out particular activities that are frequently utilized in software. Helper functions enable more modular, readable, and reusable code by decomposing complex problems into smaller jobs.



Here is an illustration of a helper function that verifies the format of a phone number:

function validatePhoneNumber(phoneNumber) {
  var phonePattern = /^\d{3}-\d{3}-\d{4}$/;
  return phonePattern.test(phoneNumber);
}
In this case, the phoneNumber parameter is passed to the validatePhoneNumber() function, which returns true if the phone number matches a predefined pattern and false otherwise. The function specifies the pattern that the phone number must match using a regular expression. A string beginning with three numbers, followed by a dash, another three digits, another dash, and then four more digits is what the regular expression looks for.



Other sections of the application that call for phone number validation can subsequently use this helper function. This function, for instance, might be used in a sign-up form to verify a user's phone number entry before the form is submitted.

Developers can make their code more modular and simpler to maintain by adding auxiliary functions. By the reuse of helper functions, code duplication is minimized and program modifications are made simpler. Also, before being utilized in the main program, helper functions can be unit tested independently to make sure they function properly.

Benefits of Using a Function
Reusability: Functions in JavaScript can be defined once and used multiple times, making code more efficient and easier to maintain.
Let's say you have a function called calculateArea that calculates the area of a rectangle. You can call this function multiple times with different parameters to calculate the area of different rectangles:

function calculateArea(length, width) {
  return length * width;
}

let area1 = calculateArea(5, 10); // returns 50
let area2 = calculateArea(3, 7); // returns 21
Modularity: Functions allow you to break down complex tasks into smaller, more manageable pieces. This can make your code easier to understand and debug.
Let's say you have a complex task that involves multiple steps, such as uploading a file, parsing its contents, and saving the results to a database. You can break down this task into smaller functions and call them sequentially:

function uploadFile() {
  // code to upload file
}

function parseFile() {
  // code to parse file contents
}

function saveToDatabase(data) {
  // code to save data to database
}

uploadFile();
let data = parseFile();
saveToDatabase(data);
Encapsulation: Functions can encapsulate data and logic, making it easier to control and manipulate.
Let's say you have a function called toggleButton that toggles the state of a button between on and off. Instead of manipulating the button directly in your code, you can encapsulate this behavior in a function and call it whenever you need to toggle the button:

function toggleButton(button) {
  if (button.getAttribute('data-state') === 'on') {
    button.setAttribute('data-state', 'off');
    button.textContent = 'Off';
  } else {
    button.setAttribute('data-state', 'on');
    button.textContent = 'On';
  }
}

let myButton = document.querySelector('#my-button');
toggleButton(myButton); // toggles button state
Scope: Functions have their own scope, which means they can access and modify variables within their scope, but not outside of it. This can help prevent naming collisions and make your code more secure.
Let's say you have a function called calculateTotal that calculates the total cost of an order. Within this function, you define a variable called subtotal. This variable is only accessible within the scope of the function, and cannot be accessed or modified from outside of it:

function calculateTotal(items) {
  let subtotal = 0;
  for (let item of items) {
    subtotal += item.price;
  }
  let tax = subtotal * 0.1;
  let total = subtotal + tax;
  return total;
}

let myItems = [
  { name: 'Widget', price: 9.99 },
  { name: 'Gadget', price: 14.99 },
  { name: 'Doohickey', price: 4.99 }
];

let myTotal = calculateTotal(myItems); // returns 31.47
Function Expressions
Using a "function expression" is another technique to define a function. The keyword "function" can be used to define a function inside of an expression. Often, the function name is left out of a function expression. An anonymous function is one that lacks a name. In order to use a function expression, it is frequently kept in a variable.

Take into account the following function statement:


Making a function expression declaration

Put an anonymous function you constructed by using the 'function' keyword and a set of parentheses with potential parameters as that variable's value. The function body is then contained by a set of curly braces.
Write the name of the variable in which the function is stored, followed by parentheses enclosing any arguments being supplied into the function, to launch a function expression.
variableName(argument1, argument2)
Function expressions cannot be called before they are defined since they are not hoisted, unlike function declarations.



Do it yourself
True or False:

Helper functions are used to break down complex problems into smaller tasks.
Helper functions can only be called from within the main function. 
Helper functions enable more modular, readable, and reusable code. 
Function expressions are hoisted in JavaScript. 
Answers
True
False
True
False


Types of Functions in JavaScript 
Arrow Function
With the help of the unique fat arrow () => notation, ES6 provides arrow function syntax, a more concise way to define functions.

Arrow functions eliminate the need to repeatedly type the word "function" while creating a function. Instead, you first include the parameters inside the "()" and then add a "=>" arrow that points to the body of the function and is encircled by " " like in the following example:

const rectangleArea = (width, height) => {
  let area = width * height;
  return area;
};
Because you will encounter each of these when reading other JavaScript code, it is crucial to be familiar with the various ways of constructing functions.

Concise Body Arrow Functions

There are numerous other ways to alter the syntax of arrow functions in JavaScript. Concise body refers to the function in its most reduced form. Below, we'll look at a number of these strategies:

Parentheses are not required around a parameter in a function that only accepts one. But, parentheses are necessary if a function has zero or more parameters.
// Zero Parameters
const functionName = () => {};

// One Parameters
const functionName = paramOne => {};

// Two or more Parameters
const functionName = (paramOne, paramTwo) => {};
Curly braces are not necessary for a function body made out of a single-line block. Whatever that line evaluates will be automatically returned if the curly braces are missing. The return keyword can be deleted, and the block's content should immediately follow the arrow =>. Implicit return describes this situation.
// Single-line block
const sum = number => number + number;

// Multi-line block
const sum = number => {
	const sum = number + number;
	return sum;             // Return statement
}


So if we have a function:

const squareNum = (num) => {
  return num * num;
};
We can refactor the function to:

const squareNum = num => num * num;
Anonymous function
The functions in JavaScript known as anonymous have no name or identification. Similar to how everyone refers to or calls you by your given name. The anonymous functions, however, lack a name, making it impossible to refer to them as regular JavaScript functions.

let variableName = function () {
    //your code here
}

variableName();     // Can call the anonymous function through this
In JavaScript, anonymous functions are formed by writing function() then code inside curly braces {}. In order to use it later, the function is subsequently assigned to a variable. When calling an anonymous function, the variable name must always be specified. When functions must be handled as values, they are helpful since they can be stored in variables.



Key Takeaways:

Anonymous functions are nameless.
The function keyword, followed by parentheses, can be used to create an anonymous function().
Inside the curly parenthesis, we can write the "function statements" just like we would for any other JavaScript function.
The output of an anonymous function is stored in variables.
Function execution
Because JavaScript is an interpreted language, the code is run line-by-line in the JavaScript runtime environment.
JavaScript behaves the same on the server as in the browser.
Synchronous code execution, including the processing of functions, variables, conditional statements, and loops, all takes place at the call-stack level.
Synchronous code is executed inside the call-stack.
Line by line, the JavaScript execution environment pushes the code into the call stack and executes it one at a time.

Call Stack
Internally, Call-stack makes use of the stack data structure. The data structure is a Last-In-First-Out (LIFO) one.
Beginning with the first line, the JavaScript execution environment reads the code line by line before beginning to put it onto the call stack. One thing to observe in this case is that none of the asynchronous code gets pushed into the call-stack. We'll talk about it in more detail in the next slides regarding how JavaScript handles it.
When a function is pushed into the call stack, it won't be removed until we return or leave the function; only then will it be deleted.
Call-stack offers the same PUSH, POP, PEEK, and TOP operations as stack data-structure.
Activity 1
Match the following: 

Option A:

Arrow Function
Concise Body Arrow Functions
Anonymous function
Function execution


Call Stack


Option B:

a. Refers to the function in its most reduced form

b. Uses unique "fat arrow" '() =>' notation to define functions
c. JavaScript code is run line-by-line in the JavaScript runtime environment
d. Data structure used internally by the JavaScript execution environment to process functions



e. Functions that have no name or identification

Solution
1-b

2-a

3-e

4-c

5-d



JavaScript Hoisting
In JavaScript, hoisting is the practice of using a function or variable before declaring it. For instance,

// by using test before declaring
console.log(test);   // undefined
var test;


The program above runs and produces an output of undefined, indicating that it behaves in the following way:

// by using test before declaring
var test;
console.log(test); // undefined
As the variable test is only declared and not assigned a value, it is given the undefined value.

Variable Hoisting
The keywords "var" and "let" do not allow hoisting when it comes to variables and constants.

For instance,

// program to display value
a = 5;
console.log(a);
var a; // 5


In the example provided, the variable a is utilized before its declaration, yet the program still runs and produces the output of 5. The program behaves in the following way:

// program to display value
var a;
a = 5;
console.log(a); // 5


However in JavaScript, initializations are not hoisted. For example,

// program to display value
console.log(a);
var a = 5;


Output

undefined


The above program behaves as:

var a;
console.log(a);
a = 5;
In the build stage, only the declaration is copied to memory. Because an is printed without being initialised, its value is hence "undefined".



Also, the variable is only raised to the top of the function when it is used inside of it. For instance,

// program to display value
var a = 4;

function greet() {
    b = 'hello';
    console.log(b); // hello
    var b;
}

greet(); // hello
console.log(b);


Output

hello
Uncaught ReferenceError: b is not defined
Variable b is raised to the top of the function greet in the example above and is now a local variable. B is therefore only reachable within the function. There is no global variable created for b.

Note: When it comes to hoisting, variable declarations are only available to the current scope.


Using the let keyword with a variable prevents it from being hoisted. 

For example,

// program to display value
a = 5;
console.log(a);
let a; // error


Output:

Uncaught ReferenceError: Cannot access 'a' before initialization
When using let, it is necessary to declare the variable first.

Function Hoisting
Functions are elevated to the top of the scope in which they are defined in JavaScript's function hoisting feature, which occurs before any code is performed. It follows that calling functions before they are defined won't result in an error.

To put it another way, the JavaScript engine looks for function and variable declarations in the code before moving them to the top of the file when a JavaScript file is loaded into the browser. Functions can be called from anywhere inside the same scope using a technique known as hoisting, even if the definition of the function comes later in the code.

For example -

// program to print the text
greet();

function greet() {
    console.log('Hi, there.');
}


Output :

Hi, there
The function "greet" is called in the aforementioned program before it is declared, and the output is displayed. This is a result of lifting.

Only declarations are hoisted; therefore, when a function is used as an expression, an error happens. For instance;

// program to print the text
greet();

let greet = function() {
    console.log('Hi, there.');
}


Output :

Uncaught ReferenceError: greet is not defined


If var were used in the above program, the error would be:

Uncaught TypeError: greet is not a function


Note: Generally, programming in other languages like Python, C, C++, and Java does not involve hoisting. Hoisting may result in negative effects on your program. Also, it's recommended to avoid hoisting and declaring variables and functions before using them. When dealing with variables, let is preferable to var.


Activity 2
Complete the crossword: 


ACROSS

3. In JavaScript, function hoisting occurs before any _________ is performed

5. In JavaScript, variable declarations are only available to the current __________.

6. When a function is used as an expression, an error happens because only __________ are hoisted.



DOWN

1. In JavaScript, initializations are not ___________.

2. A feature in JavaScript where a function or variable can be used before declaring it.

4. The variable in JavaScript that is only declared and not assigned a value.

7. When using _________ keyword with a variable in JavaScript, it prevents it from being hoisted.

Answers
ACROSS :

3- CODE

5- SCOPE

6- DECLARATIONS

DOWN : 

1- HOISTED

2- HOISTING

4- UNDEFINED

7- LET







Explore Further
Uncover and unlock new insights as you dive into the captivating content found in the provided link.

Closures in JavaScript: https://blog.hubspot.com/website/javascript-closure



Tackle these questions head-on!

Create a Counter using Closure:

Create a function called createCounter that returns another function.
Inside the createCounter function, declare a variable called count and set its initial value to 0.
Inside the returned function, increment the count variable by 1 each time the function is called.
Return the current value of count from the returned function.
Store the returned function in a variable called counter.
Test the counter by calling it multiple times and observing the output.
Solution
function createCounter() {
  let count = 0;

  return function() {
    count++;
    return count;
  };
}

const counter = createCounter();

console.log(counter()); // Output: 1
console.log(counter()); // Output: 2
console.log(counter()); // Output: 3
The count variable is defined inside the createCounter function and is accessible within the returned function due to closure.
Every time the returned function is called, it increments the count variable by 1 and returns the updated value.
The counter variable holds the returned function, which retains access to the count variable.
When we call counter() multiple times, we observe that the value of count is incremented with each call, demonstrating the concept of closures.




A function's speed and efficiency can significantly influence a program's performance.




Summary 
What did we learn?
JavaScript is a high-level, interpreted, and dynamic programming language. It is widely used to create interactive and dynamic web pages and applications.
A helper function is a reusable function that performs a specific task and can be called from other functions to simplify code. Helper functions can be used to perform common tasks such as adding or removing items from an array, validating user input, formatting data, and more.
In JavaScript, a variable is a container that holds a value and can be referenced by a name. Variables declaration can be done using the var, let, or const keywords and can store different data types, such as numbers, strings, and objects.
Function execution in JavaScript refers to calling and running a function. When a function is executed, it executes the code inside it from top to bottom. 
The execution of a function can be triggered in several ways, such as by calling the function by its name, by invoking it as a method of an object, or by using the apply or call methods.
Function expressions are used to create functions as values and can be used as arguments or assigned to variables. 
Function declarations are used to create named functions and are hoisted to the top of their scope. 
Functions in JavaScript can also take parameters, which are values passed into the function and can return a value using the return statement.
JavaScript functions can be of two types: named functions and anonymous functions. Named functions have a name and can be called using that name.
Shortcomings
Helper functions can add complexity to code if not used appropriately.
The scope and context of a function can impact function execution.
JavaScript hoisting can lead to unexpected behavior if not understood and managed properly.
Anonymous functions can be difficult to debug if they don't have a name.
Care must be taken when using function expressions with the "this" keyword, as it can refer to different objects depending on how the function is called.
Overuse of functions can result in decreased performance, especially in complex applications.
Functions should be kept concise and well-organized to maintain code readability and maintainability.
Best Practices
Use descriptive function names that accurately reflect the function's purpose and behavior
Break down complex functions into smaller, reusable helper functions
Avoid using global variables inside functions to prevent unintended consequences and make the function more portable
Always declare variables with the let or const keywords to prevent potential issues with variable hoisting
Use function expressions instead of function declarations for helper functions that don't need to be hoisted
Consider using arrow functions for simple functions that have concise, single-line bodies
Aim for functions to have a single responsibility and to be as modular and reusable as possible
Enhance Your Knowledge
More on JavaScript
https://www.joshwcomeau.com/javascript/statements-vs-expressions/
