Components, State, and Props
Session Flow
Learning Objective 
Introduction
Theme
Primary Goals
Components, State, and Props
Introduction to Components
Functional Components
Class Components
Conditional Rendering
Project Implementation Step 1
Props in Reactjs
Default Props
Project Implementation Step 2
State in Reactjs
Conventions of Using State in React
Prop Drilling
Project Implementation Step 3
Summary 
What did we learn?
Shortcomings & Challenges
Best Practices
Enhance your knowledge
Try it yourself
Learning Objective
Introduction
In React, components, states, and props are fundamental concepts crucial in building dynamic and reusable user interfaces?
Components are the building blocks of a React application. The state represents the mutable data managed by a component. Props (short for properties) are inputs that are passed to a component from its parent component.
Focus: Components, State, Props, and Conditional Rendering
Pre-requisites: JavaScript, ES6 (ECMAScript 2015) and JSX
Theme
Netflix, the streaming giant, utilizes ReactJS in its web interface. React components are responsible for rendering different sections of the Netflix UI, including the homepage, search results, and individual show pages. State and props are used to manage the user's preferences, handle playback controls, and display personalized recommendations.
Airbnb, the popular online marketplace for accommodations, employs ReactJS for its front end. They utilize React components to create reusable UI elements, such as search filters, booking forms, and interactive maps. State and props are used to manage the application's state, handle user interactions, and dynamically update the UI.
Primary Goals
Understand how to compose components by nesting them within each other. 
Learn how to define and pass props, as well as how to access and utilize them within child components. 
Understand how to define and manage state and how it impacts the rendering and behavior of components.
Understanding the component composition and learning how to break down your UI into smaller and manageable components.
 
Components, State, and Props
Introduction to Components
In React.js, a component is a reusable and self-contained piece of code that defines the structure and behavior of a part of a user interface. It represents a specific part or element of a web page or application. Components are the building blocks of a React application and can be composed together to create complex UIs.
A component can be thought of as a function or a class that returns a React element, which describes what should be rendered on the screen. Components can accept inputs called props (short for properties) that allow them to be configured and customized based on the application's needs.
notion image
React components have a few key characteristics:
Reusability: Components are designed to be reusable, meaning they can be used multiple times throughout an application or even shared across different projects.
Encapsulation: Components encapsulate their own logic and state, making them self-contained and modular. This promotes separation of concerns and makes it easier to reason about and maintain the codebase.
Composition: Components can be composed together to build complex user interfaces. They can be nested inside each other to create a hierarchical structure.
React provides two main types of components:
Functional Components: These are stateless components defined as JavaScript functions. They receive props as input and return a React element describing the UI. Functional components are simpler and recommended when state or lifecycle methods are not required.
Class Components: These are ES6 classes that extend the React.Component class. Class components have additional features, such as managing their own state and lifecycle methods. They are typically used when state or more complex logic needs to be implemented.
Components play a central role in React.js by allowing developers to build modular, reusable, and maintainable user interfaces. They promote code organization and separation of concerns and enable a declarative approach to building UIs.
Functional Components
Functional components in React.js are JavaScript functions that return a React element, describing what should be rendered on the screen. They are also known as stateless components because they do not manage their own state or have access to lifecycle methods. Instead, they focus on accepting inputs (props) and rendering UI based on those inputs.
Here's an example of a functional component in React:
import React from 'react';

function MyComponent() {
  return <div>Hello, World!</div>;
}

export default MyComponent;
In this example, the MyComponent function is a simple, functional component that returns a div element with the text "Hello, World!" as its content. This component does not accept any props or manage any internal state. It is a static component that will render the same output every time it is used.
Functional components are often used for simpler UI elements or UI parts that do not require complex logic or state management. They are lightweight and performant since they don't have the overhead of class components or state management. However, they can still be composed together and used within other components to build more complex UI structures.
ðŸ’¡
Note that with the introduction of React Hooks in React 16.8, functional components can now also manage state and utilize lifecycle methods using hooks like useState, useEffect, and others. 
Class Components
In React.js, class components are JavaScript classes that extend the React.Component class. They allow you to define the structure and behavior of a part of your user interface. While class components without using props may have limited practical use, Lets take a look how they work.
Here's an example of a simple class component:
import React, { Component } from 'react';

class MyComponent extends Component {
  render() {
    return <div>Hello, I am a class component!</div>;
  }
}

export default MyComponent;
In the above code, we define a class component named MyComponent. It extends the React.Component class, which provides the necessary functionality for React components.
The render() method is a required method in class components. It returns a React element or null, describing what should be rendered on the screen. In this example, the render() method returns a <div> element with the text "Hello, I am a class component!".
To use this component in another part of your application, you can import it and include it in the JSX code:
import React from 'react';
import MyComponent from './MyComponent';

function App() {
  return (
    <div>
      <h1>Welcome to My App</h1>
      <MyComponent />
    </div>
  );
}

export default App;
In the above code, we import the MyComponent class from its file and include it as a JSX element (<MyComponent />) inside the App functional component. When the App component is rendered, it will also render the MyComponent class component.
While class components without props might not have much functionality, they can be useful for creating static UI elements or serving as placeholders until more complex logic is added.
However, it's important to note that class components have been largely superseded by functional components and hooks in modern React development. Functional components are simpler and promote better code organization and reusability. Hooks allow functional components to manage state and lifecycle methods, making them more powerful and flexible.
Higher Order Component
In React.js, a Higher Order Component (HOC) is a pattern used for code reusability and composition. It is not a built-in feature or API in React, but rather a design pattern that leverages the composability of components in React. A Higher Order Component is a function that takes a component as an argument and returns a new component with additional or modified props.
The basic idea behind the Higher Order Component pattern is to separate concerns and logic from the presentational components. By doing so, you can create more reusable and maintainable code.
Here's a step-by-step explanation of how Higher Order Components work:
Function that takes a component as an argument: A Higher Order Component is defined as a function that accepts a React component as its input. The component being passed in is often referred to as the "base component" or the "wrapped component."
Additional logic and props: Inside the HOC, you can add additional logic, behavior, or props that you want to apply to the base component. This can include state management, side effects, or any other functionality that you want to share across multiple components.
Returns a new component: The Higher Order Component then returns a new React component, which can be the same base component with the added functionality or an entirely new component that wraps the base component.
Usage: To use the HOC, you wrap your target component with the HOC function, like a decorator. This enhances the target component with the additional functionality provided by the HOC.
Here's a simplified example of a Higher Order Component:
// Higher Order Component
const withLogger = (WrappedComponent) => {
  return (props) => {
    console.log("Component is rendering:", WrappedComponent.name);
    return <WrappedComponent {...props} />;
  };
};

// Base component
const MyComponent = (props) => {
  return <div>{props.text}</div>;
};

// Enhanced component using the HOC
const EnhancedComponent = withLogger(MyComponent);

// Usage in the application
const App = () => {
  return <EnhancedComponent text="Hello, World!" />;
};
In this example, the withLogger HOC takes the MyComponent as an argument and returns a new component that logs the name of the component before rendering it. The EnhancedComponent is then used in the App component, and when rendered, it logs: "Component is rendering: MyComponent".
By using Higher Order Components, you can share common functionality across multiple components without having to repeat the same code in each component. This helps keep your codebase clean, modular, and easier to maintain. However, it's worth noting that React hooks, introduced in React 16.8, provide an alternative and more modern way of achieving similar functionality without the need for HOCs in many cases.
Conditional Rendering
In React.js, conditional rendering refers to the ability to conditionally display or hide elements or components based on certain conditions. While the most common approach to conditional rendering involves using props, lets see an alternative technique that leverages JavaScript expressions and logical operators to conditionally render components without relying on props.
Here's an example of conditional rendering in a functional component:
import React from 'react';

function ConditionalComponent() {
  const isLoggedIn = true; // Condition for rendering

  return (
    <div>
      {isLoggedIn && <p>Welcome, User!</p>}
      {!isLoggedIn && <p>Please log in.</p>}
    </div>
  );
}

export default ConditionalComponent;
In the example above, the isLoggedIn variable represents the condition for rendering. If isLoggedIn is true, the <p>Welcome, User!</p> element will be rendered. If isLoggedIn is false, the <p>Please log in.</p> element will be rendered.
This technique utilizes the short-circuit evaluation behavior of logical operators (&& and ||). In the case of isLoggedIn && <p>Welcome, User!</p>, if isLoggedIn is false, the logical AND operator (&&) short-circuits and doesn't evaluate the right-hand side expression (<p>Welcome, User!</p>), effectively not rendering it. If isLoggedIn is true, the logical AND operator proceeds and evaluates the right-hand side expression, resulting in the element being rendered.
Similarly, the !isLoggedIn && <p>Please log in.</p> expression uses the logical NOT operator (!) to invert the condition. If isLoggedIn is false, the logical NOT operator makes it true, and the logical AND operator evaluates the right-hand side expression, rendering the <p>Please log in.</p> element.
By using JavaScript expressions and logical operators in this way, you can conditionally render components without relying on props in React.js. It provides a simple and straightforward approach when you only need basic conditional rendering in your components.
Project Implementation Step 1:
App.js
import "./styles.css";
import Navbar from "./component/navbar";

export default function App() {
  const error = false;
  return (
    <>
    {!error&&<Navbar />}
		{error && <Error/>}
    </>
  );
}
Error.js
import React from 'react'

const Error = () => {
  return (
    <div style={{display:"flex", justifyContent:"center", alignItems:"center", height:"100vh", fontSize:"large", fontWeight:"bolder"}}>
      Looks like something went wrong!!!
    </div>
  )
}

export default Error
Output:
error = false
error = false
 
error = true
error = true
Explanation:
Let's go through the code and understand its functionality:
The code imports two items: the CSS file ./styles.css and the Navbar component from the ./component/navbar file.
The App component is defined as a functional component using the arrow function syntax.
Within the component, a variable error is defined and set to false. This variable is used to conditionally render different components based on its value.
The component returns JSX representing the structure and content of the application.
Inside the JSX, there are two conditional rendering statements:
The first condition {!error && <Navbar />} checks if the error variable is false. If it is false, it renders the Navbar component.
The second condition {error && <Error/>} checks if the error variable is true. If it is true, it renders the Error component.
These conditions allow rendering different components based on the value of the error variable.
The component is wrapped with the empty fragment <>...</>. This is a shorthand way of creating a React fragment, which allows returning multiple adjacent JSX elements without adding an extra wrapper element.
Finally, the App component is exported as the default export, making it available for use in other parts of the application.
In summary, this code conditionally renders different components (Navbar and Error) based on the value of the error variable. If error is false, it renders the Navbar component; otherwise, it renders the Error component.
Props in Reactjs
In React.js, props (short for properties) are a way to pass data from a parent component to its child components. They are an essential mechanism for component communication and enable the customization and configuration of components.
Props are similar to function arguments in JavaScript. They are read-only and cannot be modified by the component receiving them. Props flow from parent components down to their children, forming a unidirectional data flow.
Here's how props are used in React:
Parent Component:
The parent component can pass data to its child component by including attributes on the child component's JSX tag. These attributes represent the props and can contain any JavaScript value, such as strings, numbers, objects, or even functions.
import React from 'react';
import ChildComponent from './ChildComponent';

function ParentComponent() {
  const name = 'John Doe';
  const age = 25;

  return <ChildComponent name={name} age={age} />;
}

export default ParentComponent;
Child Component:
The child component can access the props passed to it by declaring them as parameters in its function or class definition. These props become available as properties on the props object.
import React from 'react';

function ChildComponent(props) {
  return (
    <div>
      <p>Name: {props.name}</p>
      <p>Age: {props.age}</p>
    </div>
  );
}

export default ChildComponent;
In the example above, the ChildComponent receives name and age as props from its parent ParentComponent. It can then use these props within its JSX code to display the values.
Props can also be accessed in class components using this.props instead of props.
Props can be used for various purposes in React.js:
Data Passing: Props allow you to pass data from a parent component to its child components, enabling them to display dynamic information.
Customization: Props can be used to customize the behavior or appearance of a component. For example, you can pass a callback function as a prop to a button component to define its onClick behavior.
Configuration: Props can be used to configure components with different settings or options. For instance, you can pass a configuration object as a prop to a chart component to specify its type, colors, or data source.
It's important to note that props are immutable within a component. They should not be modified directly. If a component needs to change its behavior based on props, it should handle this logic internally or use props to update its state.
Overall, props in React.js facilitate the communication and customization between components, promoting reusability and flexibility in building UIs.
Default Props
In React.js, defaultProps is a feature that allows you to define default values for the props of a component. It is used to ensure that a component receives a fallback value when a prop is not explicitly provided or is set to undefined. defaultProps is a property of the component class and is defined as a static property or a static method.
Here's an example of using defaultProps in a functional component:
import React from 'react';

function MyComponent(props) {
  // Use props.name if provided, or use the default value 'Guest'
  const name = props.name || 'Guest';

  return <div>Hello, {name}!</div>;
}

MyComponent.defaultProps = {
  name: 'Guest'
};

export default MyComponent;
In the above example, the MyComponent component expects a name prop. If the name prop is not provided or is set to undefined, the defaultProps value of 'Guest' will be used instead.
Here's an example using defaultProps in a class component:
import React, { Component } from 'react';

class MyComponent extends Component {
  render() {
    // Use this.props.name if provided, or use the default value 'Guest'
    const name = this.props.name || 'Guest';

    return <div>Hello, {name}!</div>;
  }
}

MyComponent.defaultProps = {
  name: 'Guest'
};

export default MyComponent;
In this class component example, the defaultProps are assigned directly to the component's defaultProps property.
The benefits of using defaultProps include:
Providing fallback values: defaultProps ensure that your component will still function correctly even if certain props are not passed or are set to undefined.
Enhancing component reusability: By defining default prop values, you make it easier for other developers to use your component without explicitly providing all props.
Documentation and self-documenting code: defaultProps serve as a form of documentation, indicating which props are expected and what default values are used if not provided. This makes the code more readable and helps other developers understand the component's behavior.
It's important to note that defaultProps only set default values when a prop is undefined. If a prop is explicitly set to null, the defaultProps value will not be used. Additionally, defaultProps only applies when a prop is not provided at all, not when it is passed with an empty value (e.g., '' or []).
Overall, defaultProps is a useful feature in React.js that allows you to define default values for props, ensuring your components have fallback values when necessary.
Prop Drilling
Prop drilling is a term used in ReactJS to describe the process of passing data from a parent component through multiple intermediate child components to reach a deeply nested child component that needs access to that data. It involves passing props down the component tree, even if the intermediate components do not directly use or modify the data.
Here's an example to illustrate prop drilling:
// ParentComponent.js
import React from 'react';
import ChildComponent from './ChildComponent';

const ParentComponent = () => {
  const data = 'Hello, Prop Drilling!';

  return (
    <div>
      <ChildComponent data={data} />
    </div>
  );
};

export default ParentComponent;
// ChildComponent.js
import React from 'react';
import GrandchildComponent from './GrandchildComponent';

const ChildComponent = ({ data }) => {
  return (
    <div>
      <GrandchildComponent data={data} />
    </div>
  );
};

export default ChildComponent;
// GrandchildComponent.js
import React from 'react';

const GrandchildComponent = ({ data }) => {
  return (
    <div>
      <p>{data}</p>
    </div>
  );
};

export default GrandchildComponent;
In this example, the ParentComponent has a piece of data called data. The data prop is passed down to the ChildComponent, even though ChildComponent itself doesn't use the data prop. Then, the ChildComponent passes the data prop down to the GrandchildComponent, where it is finally used to render the data.
Prop drilling can become a problem when the component tree becomes deeply nested or when data needs to be accessed by many intermediate components that don't directly use the data. It can make the code more complex and lead to unnecessary passing of props.
To avoid excessive prop drilling, you can use alternative approaches such as React Context API or state management libraries like Redux. These approaches allow you to store and access shared data without the need to pass props through intermediate components.
Overall, prop drilling is a common pattern in React where data is passed down through component props, but it can lead to code complexity and decreased maintainability in certain cases. It's important to evaluate the structure and complexity of your application to determine if prop drilling is the best approach or if alternative methods of state management should be used.
Project Implementation Step 2:
Here, we'll build the Home page of our e-commerce app.
App.js
import "../node_modules/bootstrap/dist/css/bootstrap.min.css";
import Home from './components/Home';
import img from "./assets/bg.jpg";

function App() {
  return (
    <>
      <Home image={img}/>
    </>
  );
}

export default App;
Home.jsx
import React from "react";

const Home = ({image}) => {
  return (
    <div className="hero">
      <div className="card bg-dark text-white border-0">
        <img
          src={image}
          className="card-img"
          alt="Background"
          height="550px"
        />
        <div className="card-img-overlay d-flex flex-column justify-content-center">
          <div className="container">
            <h5 className="card-title display-3 fw-bolder mb-0">
              NEW SEASON ARRIVALS
            </h5>
            <p className="card-text lead fs-2">CHECK OUT ALL THE TRENDS</p>
          </div>
        </div>
      </div>      
    </div>
  );
};

export default Home;
Output:
notion image
Explanation:
In the given code, the concept of props in React is demonstrated. Props (short for properties) are a way to pass data from a parent component to its child component.
Let's break down the code and understand how props are used:
In the App component:
The image variable is declared and assigned the value img, which is an imported image file.
The App component returns a Home component and passes the image prop to it using the syntax image={img}. This means that the image prop of the Home component will receive the value of the img variable.
In the Home component:
The Home component is a functional component that receives props as a parameter. In this case, it receives the image prop.
Inside the component, the image prop is accessed by destructuring the props object in the function parameter: const Home = ({image}) => { ... }. This allows direct access to the image prop within the component.
The src attribute of the img tag in the JSX code is set to {image}. This means that the value of the image prop received from the parent component will be used as the source of the image.
By passing the image prop from the App component to the Home component, the image path is dynamically set in the Home component based on the value passed as a prop.
Props allow you to pass data and functionality between components, enabling component reusability and composition. They facilitate the flow of data from parent to child components and can be used to configure and customize child components based on the requirements of the parent component.
In this example, the image prop is used to set the source of an image in the Home component. However, props can be used to pass any type of data, such as strings, numbers, objects, or functions, from the parent component to the child component.
Remember to import and export the components correctly to ensure that the props are passed and received accurately between components.
 
State in Reactjs
In React.js, state is a built-in feature that allows components to store and manage data that can change over time. It represents the internal state of a component and enables the component to update and re-render based on changes in that state. State provides a way to manage dynamic and interactive components in React applications.
Here are some key points to understand about state in React.js:
State Initialization:
In class components, state is initialized in the constructor using the this.state object. For example:
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      counter: 0
    };
  }

  // ...
}
In functional components, state is managed using the useState hook introduced in React 16.8. For example:
import React, { useState } from 'react';

function MyComponent() {
  const [counter, setCounter] = useState(0);

  // ...
}
Updating State:
In class components, state is updated using the setState() method provided by the React.Component class. It merges the updated state into the existing state. For example:
this.setState({ counter: this.state.counter + 1 });
In functional components using hooks, state is updated using the state updater function returned by the useState hook. For example:
setCounter(counter + 1);
Immutable State:
In React, state should be treated as immutable, meaning it should not be directly mutated. Instead, a new state object or value should be created and set using the appropriate mechanism (setState() or the state updater function).
This immutability is important for React to perform efficient updates and determine when to re-render components.
Asynchronous State Updates:
Both setState() in class components and the state updater function in functional components can accept a function as an argument. This function receives the previous state as its argument and returns the new state value. This is useful when the new state depends on the previous state.
this.setState(prevState => ({
  counter: prevState.counter + 1
}));

setCounter(prevCounter => prevCounter + 1);
State in Functional Components:
Before React 16.8, functional components were stateless. However, with the introduction of hooks, functional components can now manage state using the useState hook.
State and Re-rendering:
When state is updated using setState() or the state updater function, React re-renders the component and its children to reflect the new state.
React performs a diffing algorithm to identify the changes between the previous and new state and only applies the necessary updates to the affected UI parts.
State in React.js is a powerful concept that enables components to be dynamic, interactive, and responsive. It allows components to manage and represent data that can change over time, resulting in a more interactive and user-friendly application.
Conventions of Using State in React
When working with a state in React, following certain conventions and best practices is helpful to ensure clean and maintainable code. Here are some common conventions for using state in React:
Initialize State in the Constructor or with useState Hook:
In class components, initialize the state in the constructor using this.state = { /* initial state values */ }.
In functional components, use the useState hook to initialize the state. For example: const [state, setState] = useState(initialState).
Use Descriptive and Meaningful State Names:
Choose clear and descriptive names for your state variables that reflect the data they represent. This enhances code readability and makes it easier for other developers to understand the purpose of each state.
Minimize the Number of State Variables:
It's generally recommended to keep the number of state variables to a minimum. If multiple values are closely related and often updated together, consider grouping them into a single object or using reducers.
Treat State as Immutable:
In React, the state should be treated as immutable. Avoid directly mutating the state object or its properties. Instead, update a new state object or value using the appropriate mechanism (e.g., setState or the state updater function from useState).
Use Functional Updates for State Dependencies:
When updating a state based on the previous state value, use the functional update form of setState or the state updater function from useState. This ensures you're working with the most up-to-date state and prevents potential race conditions.
Lift State Up:
In React, consider lifting state up to the nearest common ancestor when multiple components need access to the same state. This promotes better data sharing and reduces duplication of state.
Use Controlled Components for Form Inputs:
When dealing with form inputs, it's recommended to use controlled components. In controlled components, the value of the input is controlled by React state, allowing you to respond to user input and perform validation easily.
Avoid Storing Redundant or Derivable Data in State:
It's generally a good practice to avoid storing redundant or derivable data in a state. Instead, derive such values from the existing state or props whenever needed. This helps maintain data consistency and reduces the risk of unnecessary state updates.
Consider Performance Optimization:
For performance-critical scenarios, you can optimize state updates using techniques like memoization, shouldComponentUpdate (for class components), or React.memo (for functional components) to prevent unnecessary re-renders.
Following these conventions promotes code consistency, readability, and maintainability when working with the state in React. It helps ensure that your state management remains clean, predictable, and efficient throughout your application.
Project Implementation Step 3:
Here, we'll be working on building a part of the e-commerce app, that is the clothes section.
Product.js
import React,{useState} from 'react'
import '../../node_modules/bootstrap/dist/css/bootstrap.min.css'

const Product = () => {
    const [price,setPrice]=useState(0);
  const info = {
			"id": 3,
        "title": "Mens Cotton Jacket",
        "price": 55.99,
        "description": "great outerwear jackets for Spring/Autumn/Winter, suitable for many occasions, such as working, hiking, camping, mountain/rock climbing, cycling, traveling or other outdoors. Good gift choice for you or your family member. A warm hearted love to Father, husband or son in this thanksgiving or Christmas Day.",
        "category": "men's clothing",
        "image": "https://fakestoreapi.com/img/71li-ujtlUL._AC_UX679_.jpg",
        "rating": {
            "rate": 4.7,
            "count": 500 }
	  }
  const handleClickAdd=()=>{
    setPrice((prevCount)=>prevCount+1)
  }
  const handleClickSub=()=>{
    setPrice((prevCount)=>prevCount-1)
  }

  return (
    <div>
      <div className="col-md-6">
        <img
          src={info.image}
          alt={info.title}
          height="100px"
          width="100px"
        />
      </div>
      <div className="col-md-6">
        <h4 className="text-uppercase text-black-50">{info.category}</h4>
        <h1 className="display-5">{info.title}</h1>
        <p className="lead fw-bolder">
          Rating {info.rating && info.rating.rate}
      </p>
        <h3 className="display-6 fw-bold my-4">$ {info.price}</h3>
        <p className="lead">{info.description}</p>
        <div className="container d-flex justify-content-evenly p-2 " >
          <button  onClick={handleClickAdd}>+</button>
            <div>{price*info.price} $ {price===0?true:<div>for {price} items</div>}</div>
          <button  onClick={handleClickSub}>-</button>
        </div>
      </div>
    </div>
  )
};


export default Product;
Output:
notion image
notion image
Explanation:
In Product.js, the useState hook is used to manage state in the React component. The useState hook is a built-in hook in React that allows functional components to have state variables.
Here's how the useState hook is used in the code:
const [price, setPrice] = useState(0);
This line of code initializes a state variable called price and a corresponding function setPrice to update the value of price. The initial value of price is set to 0.
The useState function returns an array with two elements. The first element, price, is the current value of the state variable, and the second element, setPrice, is a function that allows us to update the value of price.
When setPrice is called, it updates the value of price and triggers a re-render of the component to reflect the new value. The component will render again with the updated value of price.
In the code, the setPrice function is used in two event handlers: handleClickAdd and handleClickSub.
const handleClickAdd = () => {
  setPrice((prevCount) => prevCount + 1);
};

const handleClickSub = () => {
  setPrice((prevCount) => prevCount - 1);
};
In handleClickAdd, the setPrice function is called with a callback function that takes the previous value of price (prevCount) and increments it by 1. This ensures that the state update is based on the previous value of price, rather than the stale value. Similarly, in handleClickSub, the setPrice function is called with a callback function that decrements the price by 1.
By using the setPrice function with the useState hook, the code ensures that the price state variable is updated correctly and triggers the re-rendering of the component with the updated value. This allows for the dynamic updating of the quantity and total price of the product based on user interactions with the buttons.
Summary
What did we learn?
Components are reusable and self-contained building blocks that can be used multiple times within an application or shared across different projects. This promotes code reuse and modularity.
Functional components are stateless components defined as JavaScript functions. They accept props as input and return a React element describing the UI. They are simpler and recommended when state or lifecycle methods are not required.
Class components are ES6 classes that extend the React.Component class. They have additional features such as the ability to manage state and lifecycle methods. They are used when state or more complex logic needs to be implemented.
Props are inputs or properties that are passed to components. They allow components to be configured and customized based on the application's needs. Props are read-only and should not be modified within the component.
States represent the internal data or state of a component. By using the useState hook or the this.state property in class components, you can manage and update the state. Updating the state triggers a re-rendering of the component, allowing the UI to reflect the updated data.
Props are read-only and cannot be modified within the component that receives them. Props allow you to customize the behavior and appearance of a component based on the data passed to it. 
Props can be any JavaScript value, including strings, numbers, booleans, objects, or functions. By passing props down to child components, you can create a hierarchical structure and compose complex UIs.
Conditional rendering enables components to display different content or UI based on certain conditions. You can use JavaScript's if statements, ternary operators (condition ? true: false), or logical operators (&& and ||) to render content conditionally. Conditional rendering can be based on state values, prop values, or other factors in your application's logic.
Shortcomings & Challenges
Ensuring proper synchronization can be challenging when multiple components need access to the same state or when state changes depend on previous state values.
In deeply nested component hierarchies, passing props through intermediate components that don't need them (prop drilling) can lead to code verbosity and reduce code maintainability.
React promotes unidirectional data flow, which means props are read-only.
Conditional rendering can become complex when multiple conditions or combinations of conditions must be evaluated. 
Best Practices
Use prop types or TypeScript to validate the types of incoming props. This helps catch bugs and documents the component's expected prop types.
Props passed to a component should be treated as immutable. Avoid directly mutating or modifying the prop values within the component. 
Avoid directly modifying state or prop values. Instead, use immutable data patterns (e.g., setState with functional updates or immutable data libraries like Immutable.js or Immer) to manage and update the state.
Extract complex conditional logic into separate helper functions or variables to keep JSX code clean and readable. 
 
Enhance Your Knowledge
Supercharge your knowledge by exploring the resources provided! ðŸ“š
Component Communication: Communicating Between Components in React | Pluralsight
React state vs props: https://www.knowledgehut.com/blog/web-development/react-state-vs-props
 
Try it Yourself
Let's solve these coding problems in the AlmaBetter IDE. Don't forget to join the AlmaBetter Community Platform to share your brilliant approaches and cheer each other on! ðŸš€ Happy coding! ðŸ’»ðŸ˜„
Task 1: Want to showcase your front-end coding skills? Solve these problems seamlessly in the VS Code IDE.
Problem
You have been tasked to create a simple user profile page using React. The page should display basic information about the user, such as their name, email address, and age. You need to implement two components: UserProfile and UserInfo.
UserProfile Component:
This component should be the main container for displaying user information.
It should maintain the user data in its state.
It should render the UserInfo component to display the user data.
UserInfo Component:
This component should receive the user data as props from the UserProfile component.
It should display the :
User's Name: Celeste Moon
User's Email address: celestemoon10@gmail.com
User Age: 21
                    Expected Output
                    Expected Output
 
Hints: 
Managing State in UserProfile
Use React's useState hook to maintain the user data (name, email, and age) and a state variable for displaying the age. Pass the data and showAge state as props to UserInfo.
Solution
Folder Structure:
my-app/
  src/
    components/
      UserProfile.js
      UserInfo.js
    App.js
    index.js
 
UserInfo.js
// components/UserInfo.js
import React from "react";

const UserInfo = ({ name, email, age }) => {
  return (
    <div>
      <h2>User Information</h2>
      <p>Name: {name}</p>
      <p>Email: {email}</p>
      <p>Age: {age} </p>
    </div>
  );
};

export default UserInfo;
 
UserProfile.js
// components/UserProfile.js
import React, { useState } from "react";
import UserInfo from "./UserInfo";

const UserProfile = () => {
  const [user, setUser] = useState({
    name: "Celeste Moon",
    email: "celestemoon10@gmail.com",
    age: 21
  });

  return (
    <div>
      <h1>User Profile Page</h1>
      <UserInfo name={user.name} email={user.email} age={user.age} />
    </div>
  );
};

export default UserProfile;
 
App.js
// App.js
import React from 'react';
import UserProfile from './components/UserProfile';

function App() {
  return (
    <div>
      <UserProfile />
    </div>
  );
}

export default App;
Task 2: Enumerate different approaches to avoid Props drilling in React and share this valuable information with your fellow peers on AlmaBetter's Community Platform.
