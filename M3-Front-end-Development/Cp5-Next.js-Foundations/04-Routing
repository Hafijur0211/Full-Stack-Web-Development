Routing
Session Flow
Learning Objective
Introduction
Theme
Primary Goals
Routing
Introduction to Routing in Next.js
Why routing is essential for creating multi-page applications?
Client-side and server-side routing
Routing Setup in Next.js
<Link> tag for navigation
Creating multiple pages and linking them together
How does Next.js handle routing by file system-based routing?
Activity: Fill in the blanks
Dynamic Routes
How to create dynamic routes with parameterized URLs?
Accessing route parameters using context in Next.js
Nested Routing
Programmatic Navigation
Custom 404 Page
Handling routes that don't exist
Activity: True/False
Summary
What did we learn?
Best Practices
Shortcomings & Challenges
Enhance your knowledge
Try it Yourself
 
Learning Objective
Introduction
Routing allows you to create different pages and navigate between them in a web application without triggering a full page reload. Next.js provides automatic and dynamic routing, which simplifies the process of creating and managing pages.
Focus: Next.js Dynamic Routes, Nested Routing, Programmatic Navigation, and Custom 404 Page
Pre-requisite: Basics of Next.js
Theme
TravelEx a travel booking platform where Next.js routing holds relevance. With Next.js dynamic routes, they can create a template page for destination details and use it to generate dynamic pages for each destination based on their unique IDs. Example URL would like this:  /destinations/[destinationId]  whereas /destinations/paris (Details of Paris)  and  /destinations/new-york (Details of New York). 
With nested routing, they can have separate sections for each country or region, and within those sections, display different travel packages for specific cities or tourist spots. Example URLs:/packages/countries/toronto and /packages/countries/canada. Next.js allows them to set up nested routes to organize their travel packages effectively.
On the TravelEx website, users can filter travel packages based on various criteria, such as destination, price range, or travel duration. When users select a filter, Next.js allows programmatic navigation to update the URL and display the relevant search results without a full page refresh. TravelEx can create a custom 404 page using Next.js, which provides a user-friendly and visually appealing error page. This custom 404 page can guide users back to the main navigation or suggest other popular travel destinations even if they entered an incorrect URL.
Primary Goals
Learn how to create dynamic routes and explore how to set up nested routes in Next.js to organize content effectively.
Understand the importance of programmatic navigation and its implementation.
Learn how to create a custom 404 page using Next.js to guide users and enhance their experience.
 
Routing
Introduction to Routing in Next.js
Routing is a crucial aspect of web development that determines how a web application handles and responds to different URLs. It enables users to navigate between various pages or views without reloading the entire web application. Next.js, a popular React framework, provides a powerful and intuitive routing system to build dynamic and performant web applications.
Next.js follows a file-system-based routing approach, which means that the file structure in the "pages" directory of a Next.js project automatically defines the available routes. Each file inside the "pages" directory represents a unique route accessible in the application.
For example, consider the following file structure in a Next.js project:
- pages
  - index.js
  - about.js
  - contact.js
With this file structure, Next.js automatically sets up the following routes:
/ (Homepage): Represents the content of index.js.
/about: Represents the content of about.js.
/contact: Represents the content of contact.js.
Next.js handles client-side navigation, which means that when a user clicks on a link or changes the URL, the framework efficiently loads the required components without performing a full page refresh. This approach results in a seamless and faster user experience, similar to a Single-Page Application (SPA).
Why routing is essential for creating multi-page applications?
Routing allows users to navigate between different pages of a web application without triggering a full page refresh. It provides a seamless and smooth user experience, as users can switch between pages quickly and without any noticeable delay. It is essential for creating multi-page applications for several important reasons: 
Improved User Experience: Routing in multi-page applications enhances the user experience by allowing bookmarking, URL sharing, and easy navigation using the browser's back and forward buttons.
Modular Code Organization: Routing encourages developers to structure their codebase modularly, with each page corresponding to a separate component or module, simplifying code management and maintenance.
Search Engine Optimization (SEO): Multi-page applications with routing have better SEO as each page has a unique URL, enabling search engines to index and rank individual pages more effectively.
Progressive Enhancement: Multi-page applications support progressive enhancement, making essential content accessible to all users, including those with limited JavaScript capabilities or older browsers. Advanced features can be added progressively with client-side JavaScript enhancements.
Efficient Resource Loading: Multi-page applications load only the necessary resources for each page, resulting in faster initial load times compared to SPAs, where all resources may be loaded upfront.
Flexibility and Scalability: Routing provides flexibility and scalability, allowing developers to add new pages and features to the application easily without major impacts on the existing codebase.
Server-side Rendering (SSR) and Static Site Generation (SSG): Routing is crucial for implementing SSR and SSG, which offer improved performance and SEO benefits compared to purely client-side rendering in SPAs.
Client-side and server-side routing
Client-side Routing: Client-side routing in Next.js is achieved through the use of the built-in Link component from the next/link module. This component allows you to create links between different pages in your application without triggering a full page refresh. When a user clicks on a link, Next.js will automatically fetch the required page content and update the URL without loading the entire application again.
Advantages:
Fast and smooth transitions between pages, providing a better user experience.
No full page reloads, resulting in faster navigation and reduced server load.
Allows for dynamic updates to the URL without reloading the entire page, enabling bookmarking and shareable URLs.
Example of Client-side Routing with Link component
// pages/index.js

import Link from 'next/link';

const HomePage = () => {
  return (
    <div>
      <h1>Welcome to the Home Page!</h1>
      <Link href="/about">
        <a>About Us</a>
      </Link>
    </div>
  );
};

export default HomePage;
Server-side Routing: Next.js also supports server-side routing, which is useful for scenarios where you need to perform server-side logic before rendering a page. This can include fetching data from APIs, authentication, or other server-side operations. Server-side routing is achieved using special Next.js functions like getServerSideProps or getInitialProps.
Advantages:
Ability to fetch and process data on the server before rendering the page, ensuring SEO-friendly content and better initial load times.
Enhanced security as sensitive data and logic can be kept on the server, limiting client-side exposure.
Example of Server-side Routing with getServerSideProps
// pages/users/[id].js

import { useRouter } from 'next/router';

const UserDetailPage = ({ user }) => {
  const router = useRouter();

  if (router.isFallback) {
    return <div>Loading...</div>;
  }

  return (
    <div>
      <h1>User Details</h1>
      <p>Name: {user.name}</p>
      <p>Email: {user.email}</p>
    </div>
  );
};

export async function getServerSideProps(context) {
  const { id } = context.query;
  // Fetch user data using the 'id' from the server
  const user = await fetchUserById(id);
  return {
    props: {
      user,
    },
  };
}

export default UserDetailPage;
Explanation:
The UserDetailPage is a functional component that takes a user object as a prop. This component is responsible for displaying user details on the page.
The useRouter() hook is used to get access to the routing information, including the current URL and query parameters.
The if (router.isFallback) block checks if the page is in fallback mode. In Next.js, fallback mode is used when using dynamic routing and fallback pages. During fallback mode, the server-side rendering may not have all data available, and Next.js will render a loading state (in this case, a simple "Loading..." message) until the data is fetched.
If the page is not in fallback mode, the component proceeds to render the user details. It displays the user's name and email extracted from the user prop.
The getServerSideProps function takes a context parameter that contains the query parameters from the URL, such as [id].
In this example, it extracts the id from the context.query object to get the user ID.
The function then calls an asynchronous function fetchUserById(id) to fetch the user data from the server using the extracted id.
The fetched user data is returned as props, which will be passed to the UserDetailPage component for rendering.
Routing Setup in Next.js
Setting up basic routing using Next.js is straightforward due to its automatic routing system based on the file system structure. Here's a step-by-step guide to set up basic routing in a Next.js project:
Step 1: Create a new Next.js project
To get started, you'll need Node.js installed on your machine. Open your terminal or command prompt and run the following commands:
npx create-next-app my-next-app
cd my-next-app
Step 2: Create pages
Inside the project directory, you'll find a folder called "pages." This is where you'll create pages for your application. For basic routing, you can create separate files for each page you want to create.
For example, create two files in the "pages" directory:
index.js: Represents the homepage.
const HomePage = () => {
  return (
    <div>
      <h1>Welcome to the Home Page!</h1>
    </div>
  );
};

export default HomePage;
about.js: Represents the about page.
const AboutPage = () => {
  return (
    <div>
      <h1>About Us</h1>
      <p>This is the About page content.</p>
    </div>
  );
};

export default AboutPage;
Step 3: Run the development server
To see the basic routing in action, run the following command:
npm run dev
This will start the development server. Now, open your browser and navigate to http://localhost:3000/ to see the homepage, and http://localhost:3000/about to see the about page. The content of each page will be rendered based on the components you defined in the respective files.
Output:
Home Page serving at localhost:3000 
Home Page serving at localhost:3000 
About Page serving at localhost:3000/about 
About Page serving at localhost:3000/about 
 
 
<Link> tag for navigation
The <Link> component is a special component provided by Next.js that enables client-side navigation without full page reloads. It is specifically designed for use in Next.js applications and provides a smoother and faster user experience when navigating between pages. When you use the <Link> component, Next.js pre-fetches the linked page's content, so it is instantly available when the user clicks on the link. This results in faster page transitions and better performance compared to traditional anchor tags.
Example
import Link from 'next/link';

const MyComponent = () => {
  return (
    <Link href="/about" passHref={true} legacyBehavior>
        <a>About Us</a>
    </Link>
      
  );
};

export default MyComponent;
The href prop is used to specify the destination URL that the link will navigate to. In this case, it points to the "/about" page, which means clicking on this link will take the user to the "about" page in your Next.js application.
The passHref prop is an optional prop that controls whether the <a> tag inside the <Link> component should receive the href prop. By setting passHref={true}, the <a> tag will receive the href attribute with the same value as the href prop of the <Link> component. This is useful when you want to pass additional attributes to the <a> tag.
The legacyBehavior prop enables legacy behavior for the <Link> component.
Creating multiple pages and linking them together
Step 1: Create a new Next.js project
If you haven't already set up a Next.js project, you can create one using the following commands:
npx create-next-app my-next-app
cd my-next-app
Step 2: Create Multiple Pages
Inside the "pages" directory, create separate files for each page you want to create. For example, create the following pages:
index.js
Represents the homepage.
const HomePage = () => {
  return (
    <div>
      <h1>Welcome to the Home Page!</h1>
      <p>This is the homepage content.</p>
    </div>
  );
};

export default HomePage;
about.js
Represents the about page.
const AboutPage = () => {
  return (
    <div>
      <h1>About Us</h1>
      <p>This is the About page content.</p>
    </div>
  );
};

export default AboutPage;
contact.js
Represents the contact page.
const ContactPage = () => {
  return (
    <div>
      <h1>Contact Us</h1>
      <p>This is the Contact page content.</p>
    </div>
  );
};

export default ContactPage;
Step 3: Link Pages Together
In Next.js, you can use the Link component from the next/link module to create links between pages. Import the Link component and use it to create navigation links in your components.
For example, in the index.js file, you can create links to the other pages:
index.js
// pages/index.js

import Link from 'next/link';

const HomePage = () => {
  return (
    <div>
      <h1>Welcome to the Home Page!</h1>
      <p>This is the homepage content.</p>

      {/* Link to the About page */}
      <Link href="/about" passHref={true} legacyBehavior>
        <a>About Us</a>
      </Link>
      
      {/* Link to the Contact page */}
      <Link href="/contact" passHref={true} legacyBehavior>
        <a>Contact Us</a>
      </Link>
    </div>
  );
};

export default HomePage;
Similarly, you can add links to the other pages in their respective components. Once you have linked the pages together, the Next.js automatic routing system will take care of the navigation between pages without requiring a full page refresh.
Step 4: Run the Development Server
To see the linked pages in action, run the development server:
npm run dev
Open your browser and navigate to http://localhost:3000/ to see the homepage. You should see links to the "About Us" and "Contact Us" pages. Clicking on these links will navigate to the corresponding pages without a full page refresh, demonstrating Next.js client-side routing in action.
Output:
Home Page serving at localhost:3000 
Home Page serving at localhost:3000 
Routed to About Page upon clicking on About Us from Home Page
Routed to About Page upon clicking on About Us from Home Page
Routed to Contact Us Page upon clicking on Contact Us from Home Page
Routed to Contact Us Page upon clicking on Contact Us from Home Page
 
How does Next.js handle routing by file system-based routing?
Next.js handles routing using a file system-based routing approach, which means that the file structure inside the "pages" directory determines the routes for the application. This approach simplifies the process of creating and managing routes, as developers can organize pages as separate files, and Next.js automatically sets up the routes based on the file names and structure.
Here's how Next.js handles routing through file system-based routing:
Automatic Route Generation: Inside the "pages" directory of a Next.js project, each file represents a unique route in the application.
For example, if you have the following files in the "pages" directory:
- pages
  - index.js
  - about.js
  - contact.js
Next.js will automatically generate the following routes:
/ (Homepage): Represents the content of index.js.
/about: Represents the content of about.js.
/contact: Represents the content of contact.js.
Nested Routes: Next.js also supports nested routes through the use of directories inside the "pages" directory.
For example, if you have the following file structure:
- pages
  - products
    - index.js
    - [id].js
  - about.js
Next.js will generate the following routes:
/products: Represents the content of products/index.js.
/products/:id: Represents the content of products/[id].js, where :id is a dynamic parameter.
Dynamic Routes:Next.js supports dynamic routes, allowing developers to create pages based on dynamic data or parameters. Dynamic routes are defined using square brackets [ ] in the file names.
For example, if you have the following file in the "pages" directory:
- pages
  - users
    - [id].js
Next.js will generate dynamic routes like /users/1, /users/2, etc., where 1, 2, etc., are dynamic parameters.
Index Routes: Next.js automatically maps the index.js file to the root route (/).
For example, if you have index.js in a subdirectory like pages/about/index.js, Next.js will map it to the route /about.
Custom 404 Page: If you create a file named 404.js inside the "pages" directory, Next.js will use it as a custom 404 page. This allows you to create a user-friendly and visually appealing error page for pages that don't exist or for routes that are not matched.
 
We will delve deeper into the concepts discussed above to comprehensively understand how they work!
Activity: Fill in the blanks
Routing in Next.js is based on a __________(hierarchical/file-based/both)  approach, where each file inside the "pages" directory corresponds to a unique route accessible in the application.
The Next.js automatic routing system supports __________(SSG/SIngle-page app/scalability), which allows developers to add new pages and features to the application easily without major impacts on the existing codebase.
Next.js handles client-side navigation through the use of the built-in __________ (Link/Route/Nav) component from the next/link module, allowing users to navigate between pages without triggering a full page refresh.
The getServerSideProps function is used in Next.js for __________(server-side/client-side/static site generation(SSG) ) routing, allowing developers to fetch and process data on the server before rendering a page.
Answer
file-based
scalability
Link
server-side
Dynamic Routes
Dynamic routing in Next.js is a powerful feature that allows developers to create pages with dynamic content based on specific data or parameters in the URL. Unlike static routes, where each page is predefined, dynamic routing enables the generation of pages on-the-fly, making it easier to handle a wide range of data-driven scenarios.
In Next.js, dynamic routing is achieved using placeholders (also known as "slug" or "bracket" notation) in the file names of the "pages" directory. These placeholders are enclosed in brackets ([ ]) and can be used to represent dynamic values in the URL.
For example, consider the following file structure in the "pages" directory:
- pages
  - posts
    - [id].js
With this setup, Next.js recognizes the [id] placeholder and generates dynamic routes based on the unique IDs of posts. For instance, if there are posts with IDs 1, 2, and 3, Next.js will automatically create routes like /posts/1, /posts/2, and /posts/3. When a user visits any of these URLs, the posts/[id].js file will be responsible for rendering the appropriate content based on the id parameter.
Dynamic routing in Next.js is a powerful tool for building data-driven and content-rich web applications. It allows developers to create pages with unique URLs based on dynamic data, making the application more flexible and interactive. By using getStaticProps or getServerSideProps, Next.js enables seamless data fetching and rendering, making dynamic routing a versatile feature for various use cases.
How to create dynamic routes with parameterized URLs?
Creating dynamic routes with parameterized URLs in Next.js involves a few straightforward steps. Let's go through the process:
Step 1: Set Up the Project
Assuming you already have a Next.js project set up, navigate to the "pages" directory where you want to create the dynamic route.
Step 2: Create index.js file
index.js
// Home Page

const HomePage = () => {
  return (
    <div>
      <h3>Welcome to the Home Page!</h3>
     
    </div>
  );
};

export default HomePage;
Step 3: Create a Dynamic Route File
Inside the "pages" directory, create a new file with square brackets [ ] to indicate that it is a dynamic route. The name you use inside the brackets will be the parameter name that you can access in your component.
For example, if you want to create a dynamic route to display details of a specific user with their ID, create a file named [id].js:
- pages
  - items
    - [id].js
Step 4: Implement the Dynamic Route Component
In the [id].js file, you can access the dynamic value (ID) from the URL using the useRouter hook from next/router.
[id].js
// Home Page

const HomePage = () => {
  return (
    <div>
      <h3>Welcome to the Home Page!</h3>
     
    </div>
  );
};

export default HomePage;
 
 
Output:
Home Page serving at localhost:3000 
Home Page serving at localhost:3000 
 
Dynamic route serving at localhost:3000/items/123 , showing Item ID dynamically
Dynamic route serving at localhost:3000/items/123 , showing Item ID dynamically
 
 
Accessing route parameters using context in Next.js
In Next.js, you can access route parameters (dynamic segments of the URL) using either the useRouter hook or the context parameter in the getServerSideProps or getStaticProps functions. Both methods allow you to extract the dynamic values from the URL and use them in your components or data fetching functions.
The context parameter in the getServerSideProps or getStaticProps functions provides access to the routing information, including route parameters. You can extract the dynamic values from the context.query object.
Step 1: Create a Dynamic Route File
First, create a dynamic route file in the "pages" directory. You can do this by creating a new file with square brackets [ ] to indicate that it is a dynamic route. The name you use inside the brackets will be the parameter name that you can access in your component using context.
For example, create a file named [id].js to handle dynamic routes with an id parameter:
[id].js
// pages/users/[id].js

const UserDetailPage = ({ userId }) => {
  return (
    <div>
      <h1>User Details</h1>
      <p>User ID: {userId}</p>
    </div>
  );
};

export default UserDetailPage;
Step 2: Access Route Parameters using context in getServerSideProps or getStaticProps
Inside the dynamic route file ([id].js in this case), you can access the route parameter using context.params. context is one of the parameters passed to the getServerSideProps or getStaticProps functions.
pages/users/[id].js
// pages/users/[id].js

const UserDetailPage = ({ userId }) => {
  return (
    <div>
      <h1>User Details</h1>
      <p>User ID: {userId}</p>
    </div>
  );
};

export async function getServerSideProps(context) {
  const { id } = context.params; // Access the 'id' parameter from the URL
  // You can also access other properties from 'context' if needed
  // const { req, res, query, resolvedUrl, params } = context;

  return {
    props: {
      userId: id, // Pass the 'id' parameter as a prop to the component
    },
  };
}

export default UserDetailPage;
Step 3: Testing the Route Parameter
Now, when you access a URL with a dynamic segment, such as /users/123, Next.js will render the [id].js page with the corresponding userId as a prop. In this example, the userId prop will be equal to 123.
You can test this by running your Next.js development server.
Access the page in your browser, and you should see the rendered content with the user ID dynamically extracted from the URL.
By following these steps, you can successfully access route parameters using context in Next.js, allowing you to create dynamic pages that fetch data based on the parameters passed in the URL.
Output:
Home Page serving at localhost:3000 
Home Page serving at localhost:3000 
 
Dynamic route using getServerSideProps serving at localhost:3000/users/123 ,showing Item ID dynamically
Dynamic route using getServerSideProps serving at localhost:3000/users/123 ,showing Item ID dynamically
 
 
The choice between using useRouter (client-side) and context (server-side) depends on your specific use case and whether you need the routing information in the client-side component or during server-side rendering.
Nested Routing
Nested routing in Next.js allows you to create a hierarchical structure of pages by organizing them in subdirectories. Each level of the subdirectory can represent a specific section or category of the application. This helps in managing complex applications with multiple pages and components. Let's go through the steps to implement nested routing in Next.js:
Step 1: Create Nested Directories for Pages
- pages
  - products
    - index.js
    - [id].js
  - about.js
In this example, we have a nested route for "products." The "products" directory contains two files:
index.js: Represents the products homepage (e.g., /products).
[id].js: Represents individual product details, where [id] is a dynamic parameter (e.g., /products/123).
Step 2: Implement Nested Pages
Inside each nested page file, you can create the corresponding components or content. For example:
pages/products/index.js
// pages/products/index.js

const ProductsHome = () => {
  return (
    <div>
      <h1>Products Homepage</h1>
      {/* Add content for the products homepage */}
    </div>
  );
};

export default ProductsHome;
pages/products/[id].js
// pages/products/[id].js

import { useRouter } from 'next/router';

const ProductDetail = () => {
  const router = useRouter();
  const { id } = router.query; // Access the 'id' parameter from the URL

  return (
    <div>
      <h1>Product Details</h1>
      <p>Product ID: {id}</p>
      {/* Add content for the individual product details */}
    </div>
  );
};

export default ProductDetail;
Similar you can use About Page to navigate through localhost:3000/about .
Run your Next.js development server to test the nested routing.
Output:
Product Homepage serving at localhost:3000/products 
Product Homepage serving at localhost:3000/products 
 
Product Details are dynamically fetched at localhost:3000/products/123 
Product Details are dynamically fetched at localhost:3000/products/123 
 
 
 
With this setup, Next.js automatically generates the routes for nested pages, making the application more organized and easier to manage.
Programmatic Navigation
Programmatic navigation in Next.js allows you to navigate between pages programmatically using JavaScript code, without relying on user clicks or browser actions. This is useful for scenarios where you want to trigger navigation based on certain events or conditions within your application.
In Next.js, you can perform programmatic navigation using both the push and replace methods from the useRouter hook. Both methods allow you to navigate between pages programmatically, but they have some differences in how they update the browser history.
Here's how to perform programmatic navigation with push method in Next.js with the following folder and file structure:
- pages
  - index.js
  - about.js
  - contact.js
- components
  - Navigation.js
First, make sure you have Node.js and npm installed. Create a new Next.js project.
Step 1: Create Pages
Create the necessary pages in the "pages" directory.
pages/index.js
import Navigation from '../components/Navigation';

const HomePage = () => {
  return (
    <div>
      <h1>Welcome to the Home Page!</h1>
      <Navigation />
    </div>
  );
};

export default HomePage;
pages/about.js
import Navigation from '../components/Navigation';

const AboutPage = () => {
  return (
    <div>
      <h1>About Us</h1>
      <p>This is the about page content.</p>
      <Navigation />
    </div>
  );
};

export default AboutPage;
pages/contact.js
import Navigation from '../components/Navigation';

const ContactPage = () => {
  return (
    <div>
      <h1>Contact Us</h1>
      <p>This is the contact page content.</p>
      <Navigation />
    </div>
  );
};

export default ContactPage;
Step 3: Create Navigation Component
Create the Navigation component in the "components" directory. This component will include links to navigate between pages programmatically.
components/Navigation.js
import Link from 'next/link';
import { useRouter } from 'next/router';

const Navigation = () => {
  const router = useRouter();

  // Function to handle programmatic navigation
  const handleNavigate = (path) => {
    router.push(path);
  };

  return (
    <div>
      <h2>Navigation</h2>
      <ul>
        <li>
          <Link href="/">Home</Link>
        </li>
        <li>
          <Link href="/about">About</Link>
        </li>
        <li>
          <Link href="/contact">Contact</Link>
        </li>
      </ul>
      <button onClick={() => handleNavigate('/about')}>Go to About</button>
    </div>
  );
};

export default Navigation;
In the Navigation component, we use the Link component from next/link to create navigation links that will perform client-side navigation. We also have a button that demonstrates how to use the handleNavigate function for programmatic navigation.
Run your Next.js development server.
Output:
Note: The push method is primarily used for client-side navigation, meaning it does not make a full server-side request. Instead, it leverages client-side routing to update the URL and render the new page without a full page refresh.
With programmatic navigation in Next.js, you can dynamically control the flow of your application and redirect users to different pages based on various events or conditions, providing a more interactive and dynamic user experience.
Using replace method for Programmatic Navigation
The replace method replaces the current entry in the browser's history stack with the new page, effectively removing the current page from the history. This means that users won't be able to use the browser's back button to navigate back to the previous page after using the replace method.
import { useRouter } from 'next/router';

const MyComponent = () => {
  const router = useRouter();

  // Function to handle programmatic navigation using replace
  const handleNavigate = () => {
    router.replace('/destination'); // Replace '/destination' with the desired URL
  };

  return (
    <div>
      <h1>My Component</h1>
      <button onClick={handleNavigate}>Navigate to Destination</button>
    </div>
  );
};
In both cases, when the button is clicked, the handleNavigate function will be called, triggering programmatic navigation to the specified destination URL. Choose between push and replace based on how you want the browser history to behave after the navigation.
In summary, programmatic navigation in Next.js can be achieved using the push and replace methods from the useRouter hook. The push method adds a new entry to the browser's history stack, while the replace method replaces the current entry in the history stack. Choose the appropriate method depending on your desired navigation behavior and user experience.
Custom 404 Page
Creating a custom 404 page in Next.js is straightforward and allows you to provide a more user-friendly and visually appealing error page when a user accesses a page that doesn't exist or encounters a 404 error. To set up a custom 404 page, follow these steps:
Step 1: Create the Custom 404 Page
Inside the "pages" directory of your Next.js project, create a new file named 404.js. This file will serve as your custom 404 page.
404.js
// pages/404.js
const Custom404 = () => {
  return (
    <div>
      <h1>404 - Page Not Found</h1>
      <p>Sorry, the page you are looking for does not exist.</p>
    </div>
  );
};

export default Custom404;
In this example, we've created a simple custom 404 page with a header displaying "404 - Page Not Found" and a message to inform the user that the requested page doesn't exist.
Step 2: Styling the Custom 404 Page (Optional)
You can also add CSS or styling to the 404.js file to make the error page visually appealing and consistent with the rest of your application's design.
To test the custom 404 page, run your Next.js development server.
Now, if you try to access a non-existent route or any route that doesn't have a corresponding page in the "pages" directory, Next.js will automatically render your custom 404 page.
For example, navigating to http://localhost:3000/nonexistent-route or http://localhost:3000/almabetter/web-development will display the custom 404 page you created.
Output:
Home Page serving at localhost:3000 
Home Page serving at localhost:3000 
Navigating to a nonexistent route at localhost:3000/almabetter/web-development 
Navigating to a nonexistent route at localhost:3000/almabetter/web-development 
Handling routes that don't exist
In Next.js, you can handle routes that don't exist by creating a custom 404 page, as explained in the previous response. However, you may also want to handle other types of routes or scenarios where the default custom 404 page might not be sufficient. Here are some additional approaches to handle routes that don't exist or other specific error scenarios:
Custom Error Pages:
Besides creating a custom 404 page, you can create custom error pages for different types of errors, such as 500 (internal server error) or 403 (forbidden). To do this, you must create individual files for each error status code in the "pages" directory. When an error occurs with the corresponding status code, Next.js will render the respective custom error page.
Fallback Component (404):
If you need more control over handling routes that don't exist, you can use the fallback property with the Dynamic Import feature of Next.js. This allows you to provide a custom fallback component for routes that are not defined explicitly.
// pages/[...slug].js
const FallbackPage = () => {
  return (
    <div>
      <h1>404 - Page Not Found</h1>
      <p>Sorry, the page you are looking for does not exist.</p>
    </div>
  );
};

export default FallbackPage;
In this example, [...slug].js will be a fallback component for all undefined routes. It will match any undefined route and display the custom 404 message.
Redirects:
If you want to redirect users from one URL to another, you can use the useRouter hook and the replace method to perform client-side redirects.
import { useRouter } from 'next/router';

const MyComponent = () => {
  const router = useRouter();

  // Function to handle redirect
  const handleRedirect = () => {
    router.replace('/new-url'); // Replace '/new-url' with the desired URL
  };

  return (
    <div>
      <h1>My Component</h1>
      <button onClick={handleRedirect}>Redirect to New URL</button>
    </div>
  );
};
This method allows you to handle cases where you want to redirect users to a different URL programmatically.
With these approaches, you can effectively handle routes that don't exist or other specific error scenarios in your Next.js application, providing a more controlled and user-friendly experience when users encounter errors or navigate to undefined routes.
Activity: True/False
In Next.js, dynamic routing is achieved using placeholders enclosed in angle brackets ([ ]).
Next.js allows developers to create nested routes by organizing pages in subdirectories, but it does not support hierarchical page structures.
Next.js only supports static routes, where each page is predefined, and dynamic routing is not possible.
Next.js supports both client-side and server-side routing for dynamic pages.
Programmatic navigation in Next.js allows you to navigate between pages programmatically using the 'push' method from the 'useRouter' hook.
Answer
True
False
False
True
True
Summary
What did we learn?
Routing is essential in web development to handle and respond to different URLs, enabling navigation between pages without full page reloads.
Next.js, a React framework, provides a file-system-based routing approach, where files in the "pages" directory automatically define routes in the application. Each file in the "pages" directory represents a unique route accessible in the application.
Benefits of routing in multi-page applications include improved user experience, modular code organization, better SEO, progressive enhancement, efficient resource loading, flexibility, and support for SSR and SSG.
To link pages together, the Link component is used in Next.js to create navigation links without full page reloads.
Dynamic routing with parameterized URLs in Next.js involves using placeholders in file names and generating pages with unique URLs based on dynamic data.
Dynamic routing allows for data-driven scenarios and seamless data fetching and rendering in Next.js applications.
Next.js allows accessing route parameters through useRouter hook or context parameter in getServerSideProps or getStaticProps functions. The context.query object holds the dynamic values from the URL.
Next.js supports nested routing for organizing pages in subdirectories, creating a hierarchical structure for complex applications.
Next.js allows programmatically navigating between pages using the push and replace methods from useRouter.
custom 404 page in Next.js can be created to handle routes that don't exist or other error scenarios. Additionally, custom error pages for specific status codes and use fallback components or redirects for more control over handling undefined routes can be created.
Best Practices
Optimize Route Structure: Organize the "pages" directory thoughtfully, grouping related pages and components together to keep the codebase manageable and maintainable.
Proper Error Handling: When creating custom error pages, ensure that they provide meaningful feedback to users, helping them understand the error and guiding them to appropriate actions.
Design Clear and Consistent URLs: For better user experience and SEO. Avoid unnecessary complexity in route names and parameter structures.
Use Asynchronous Data Fetching: Adopt asynchronous data fetching methods such as getServerSideProps or getStaticProps to ensure efficient and optimized data rendering.
Shortcomings & Challenges
Complexity with Nested Routing: It can lead to more intricate file structures and potentially make managing and maintaining the codebase harder.
Handling Large Number of Routes: Maintaining all the "pages" directory pages might lead to potential performance issues and difficulty in finding specific pages.
Code Duplication: If multiple pages share similar functionality or components, it might result in code duplication, leading to maintenance challenges and increased bundle sizes.
 
Enhance your knowledge
Supercharge your knowledge by exploring the resources provided! 📚
Next.js Routes (official doc): https://nextjs.org/docs/pages/building-your-application/routing
Next.js App Router: https://www.builder.io/blog/next-13-app-router
Next.js API Routes: https://www.telerik.com/blogs/nextjs-api-routes-what-need-know
 
Try it Yourself
Let's solve these coding problems in the AlmaBetter IDE. Don't forget to join the AlmaBetter Community Platform to share your brilliant approaches and cheer each other on! 🚀 Happy coding! 💻😄
Task 1: Challenge your frontend expertise by solving these coding questions using the VS Code IDE.
Problem
Create a Custom 500 Error page (Internal Server Error).
Solution
// pages/500.js
const Custom500 = () => {
  return (
    <div>
      <h1>500 - Internal Server Error</h1>
      <p>Sorry, something went wrong.</p>
    </div>
  );
};

export default Custom500;
Task 2: Feel free to add additional information or formatting to enhance the user experience. Share your experience and insights with your Cohort group on AlmaBetter's Community Platform.
 
