State Management and Optimization
Session Flow
Learning Objective
Introduction
Theme
Primary Goals
State Management and Optimization
Local State
Props Drilling
Building a deeply-nested app for prop drilling
Resolving prop drilling by using the Context API
createContext
Provider
Consumer
useContext
Project Implementation Step 1
Optimizing React Apps
The useMemo Hook
The useCallback Hook
Difference between useMemo and useCallback
Project Implementation Step 2
Throttling and Debouncing Event Action in JavaScript
Debouncing
Throttling
Avoid using Index as a key for map
Code Splitting using React.Lazy & Suspense
What is code splitting?
Dynamic Imports
Project Implementation Step 3
Summary 
What did we learn?
Shortcomings & Challenges
Best Practices
Enhance your knowledge
Try it yourself
Learning Objective
Introduction
State management is an essential aspect of building complex applications. It involves managing and organizing the data that drives the application's behavior and user interface.
Focus: Prop drilling, Component state, Global state, and State normalization
Prerequisites: Javascript, React, React Hooks
Theme
Netflix utilizes state management and optimization techniques in their React-based applications to deliver a seamless user experience. They employ techniques like code splitting and lazy loading to optimize the initial load time of their application. In their large-scale applications, Netflix also uses state management libraries like Redux and MobX to handle complex state management scenarios.
Airbnb, the popular accommodation marketplace, leverages state management and optimization techniques in its React applications. They have adopted Redux as their primary state management solution, allowing them to manage and share state across components efficiently. Additionally, Airbnb focuses on performance optimization by utilizing techniques like code splitting, lazy loading, and server-side rendering (SSR) to enhance their application's performance.
Primary Goals
Gain a solid understanding of state management concepts in React, such as local component state, context API, and third-party libraries like Redux or MobX.
Learn how to manage state in your React applications efficiently.
Familiarize yourself with popular state management libraries like Redux, MobX, or Recoil. 
 
State Management and Optimization
Alan was working on a web application that had a complex user interface. The application had many different components that needed to share data and communicate with each other. As he began to build the application, he quickly realized that he needed to manage the state of the application carefully to prevent it from becoming too complicated and difficult to maintain. Alan started by using the local state to manage the state of individual components. Local state is a type of state management in ReactJS where the state is managed within a single component. 
This allowed him to manage the state of each component independently, making it easier to debug and maintain.
Local State
In ReactJS, the props and state play crucial roles in managing data for each component. The state is specific to a component and controls its behavior throughout its lifespan.
It acts as a data structure that tracks changes in a React application, such as storing values, form inputs, and data retrieved from an API. Unlike props, the local state of a component is private and cannot be modified by other components.
To create components with the local state in React, you must use ES6 classes with a constructor function to initialize the component's initial requirements. Alternatively, you can use the useState Hook to create functional components with the local state.
When developing a component using ES6 classes, React automatically re-renders the component whenever its state changes and this is done through the setState function. This re-rendering process is crucial for updating the application's state.
Here is an example:
import React, { useState } from 'react';

const FlowerShop = () => {
  const [roses, setRoses] = useState(100);

  const buyRose = () => {
    setRoses(roses + 1);
  };

  return (
    <div>
      <button onClick={buyRose}>Buy Rose</button>
      {roses}
    </div>
  );
};

export default FlowerShop;
Consider a component that simulates a flower shop with an internal tracking system to monitor the number of roses in the store. This tracking system works efficiently as long as the FlowerShop component is the only entity that requires access to this state. 
However, if the store decides to expand and open a second branch, the second flower shop would also need to access the number of available roses stored in roses. Unfortunately, this is impossible with the local state since other components cannot access it.
We have identified a major drawback of using local state: the inability to share state with other components. However, if there is a need to track an isolated state that should not be accessible to other parts of the application, such as the UI state, then the local state is an ideal solution for this scenario.
Props Drilling
Managing state in React applications can be challenging, particularly when data must be transferred from a top-level component to components nested deep within the application hierarchy.
Prop drilling refers to passing data through multiple nested children components to ultimately reach a deeply-nested component. However, most of these intermediate components have no use for the data and are only serving as carriers for the data to reach its intended destination. 
This approach is problematic as it negatively impacts component reusability and app performance due to the unnecessary passing of data through various components. The term "drilling" is used because these components are compelled to take in irrelevant data and pass it to the next component until it finally reaches its destination.
Let us examine an example scenario that could result in prop drilling.
Building a deeply-nested app for prop drilling
Let's consider a hypothetical scenario where we are developing an application that greets users by their name upon logging in. The following is a visual representation of the demo app we will discuss.
notion image
We will not discuss the styling details to keep our code concise. Our main objective is to clearly understand the app's appearance. 
Next, we will examine the component hierarchy to comprehend the interconnection between the various components.
The issue we are facing is that the user object containing the user's name is only accessible at the root component level, specifically the App component. However, the component responsible for rendering the welcome message, which is the Message component, is nested deep within the app. 
As a result, we need to find a way to pass down the user object to the Message component. The blue arrows in the diagram illustrate how the user object is passed down through multiple nested components, eventually reaching the Message component, which uses the object to render the welcome message with the user's name.
The scenario we just discussed is a common example of prop drilling. To solve this issue, developers usually turn to the Context API as a solution, often overlooking the potential complications it can cause. 
Now that we have an overview of the project's structure, it's time to delve into the actual code implementation.
import { useState } from "react";

function App() {
  const [user, setUser] = useState({ name: "Steve" });
  return (
    <div>
      <Navbar />
      <MainPage user={user} />
    </div>
  );
}
export default App;

// Navbar Component
function Navbar() {
  return <nav style={{ background: "#10ADDE", color: "#fff" }}>Demo App</nav>;
}

//MainPage Component
function MainPage({ user }) {
  return (
    <div>
      <h3>Main Page</h3>
      <Content user={user} />
    </div>
  );
}

// Content Component
function Content({ user }) {
  return (
    <div>
      <Message user={user} />
    </div>
  );
}

//Message Component
function Message({ user }) {
  return <p>Welcome {user.name}</p>;
}
Instead of dividing our components into separate files and importing each individually, we have placed them all in a single file as separate function components. 
This allows us to use them without any external imports. As a result, the output we obtain will be:
notion image
Now that we have a basic working app, letâ€™s compare this solution to prop drilling by solving it again using the Context API.
Resolving prop drilling by using the Context API
The Context API is a useful tool for sharing data among multiple components without manually passing data through props. It is particularly suitable for use cases such as theming, user language, and authentication.
createContext
To begin working with the Context API, we first need to create a context by utilizing the createContext function from React.
const UserContext = createContext(initialValue);
The createContext function has an optional initial value parameter. Once the context is created, it will have two React components at its disposal - Provider
and Consumer. 
These components will be utilized in the implementation of the Context API.
Provider
We will use the Provider component to wrap the components that require access to our context.
<UserContext.Provider value={{ user: "Steve" }}>
 ....
</UserContext.Provider>
The Provider component has a prop called value, which can be accessed from all components wrapped inside the Provider. It is responsible for providing access to the context data.
Consumer
Once the Provider component has been utilized to wrap all components that require access to the context, we need to specify which component will consume the context data.
The Consumer component enables a React component to subscribe to context changes. The component then provides the data using a render prop.
<UserContext.Consumer>
 {value => /* Display something based on the value of the context. */}
</UserContext.Consumer>
useContext
In case you're not familiar with React Hooks, let me briefly explain them to you:
React Hooks enable us to manage state data inside functional components without the need for creating class components.
The useContext hook provides a way to connect and consume a context. It takes a single argument, which is the context that we wish to access.
const { user } = useContext(UserContext);
Using the Context API and the useContext hook makes our code cleaner and easier to maintain than using the Consumer component. Let's now see how it can be applied in a real-world example, using the same application as before.
We'll create a context and pass the user object to the context provider. Then, we'll wrap the desired components with the context provider and access the state it holds inside the specific component that needs it.
import { createContext, useContext } from "react";

//Creating a context
const UserContext = createContext();

function App() {
  return (
    <div>
      <Navbar />
      <UserContext.Provider value={{ user: "Steve" }}>
        <MainPage />
      </UserContext.Provider>
    </div>
  );
}
export default App;

function Navbar() {
  return <nav style={{ background: "#10ADDE", color: "#fff" }}>Demo App</nav>;
}

function MainPage() {
  return (
    <div>
      <h3>Main Page</h3>
      <Content />
    </div>
  );
}

function Content() {
  return (
    <div>
      <Message />
    </div>
  );
}

function Message() {
// Accessing the state that's provided by the wrapper of the context provider.
  const { user } = useContext(UserContext);
  return <p>Welcome {user} :)</p>;
}
Accessing the state that's provided by the wrapper of the context provider.To begin, we import two hooks, namely createContext and useContext. The former is used to create a context, while the latter will be used to extract the state provided by a context provider.
Next, we invoke the createContext hook, which creates a context object with an empty value. We then store this object in a variable named UserContext.
After this, we proceed to wrap the MainPage component with the Context.Provider. Here, we pass the user object to it, providing the data to every component nested within the MainPage component.
In summary, we used the useContext Hook and the Context API to solve the problem of prop drilling in our example application. We imported the createContext and useContext Hooks, then created a UserContext context object with an initial empty value using the createContext Hook.
Next, we wrapped the MainPage component with the Context.Provider
and passed the user object to it, making it available to all the components nested within it. Finally, we extracted the user object in the Message component using the useContext Hook and destructuring.
The resulting code is leaner and cleaner, and we no longer need to pass down the user prop through the intermediary components. Overall, the Context API can be useful in cases such as authentication, where you need to check if the user is authenticated in several unrelated components.
Project Implementation Step 1
App.js
import React, { useState } from 'react';
import ParentComponent from './ParentComponent';
export const MyContext = React.createContext();

const App = () => {
  const [sharedState, setSharedState] = useState({
    message: 'Hello from Context!',
    count: 0,
    incrementCount: () => {
      setSharedState((prevState) => ({
        ...prevState,
        count: prevState.count + 1
      }));
    }
  });

  return (
    <MyContext.Provider value={sharedState}>
      <div>
        <h1>App Component</h1>
        <ParentComponent />
      </div>
    </MyContext.Provider>
  );
};

export default App;
ParentComponent.js
import React from 'react';
import ChildComponent from './ChildComponent';

const ParentComponent = () => {
  return (
    <div>
      <h2>Parent Component</h2>
      <ChildComponent />
    </div>
  );
};

export default ParentComponent;
ChildComponent.js
import React, { useContext } from 'react';
import { MyContext } from './App';

const ChildComponent = () => {
  const context = useContext(MyContext);

  return (
    <div>
      <h3>Child Component</h3>
      <p>Message: {context.message}</p>
      <p>Count: {context.count}</p>
      <button onClick={context.incrementCount}>Increment Count</button>
    </div>
  );
};

export default ChildComponent;
Output:
notion image
Explanation: 
Let's go through the working of each component mentioned:
App.js:
App.js is the main component where the Context API is set up.
We create a context using React.createContext() and store it in MyContext.
Inside the App function component, we use the useState hook to initialize the sharedState variable. It contains a message, count, and an incrementCount function.
The incrementCount function updates the count value by using the setSharedState function. It spreads the previous state and increments the count by 1.
The sharedState and setSharedState are passed as values to the MyContext.Provider. This allows all child components to access the shared state.
The ParentComponent is rendered inside the MyContext.Provider to ensure the child components can access the shared state.
ParentComponent.js:
ParentComponent is a functional component that serves as an intermediary between App.js and ChildComponent.js.
It doesn't have its own state or logic related to the shared state.
It simply renders a heading and the ChildComponent.
ChildComponent.js:
ChildComponent is a functional component that consumes the shared state using the Context API.
It uses the useContext hook and provides the MyContext to access the shared state stored in App.js.
The shared state is received in the context variable through the useContext(MyContext) statement.
The component renders the received message, count, and a button.
When the button is clicked, it invokes the incrementCount function from the shared state to update the count value in App.js.
The overall working of these components is as follows:
The App component sets up the Context API and provides the shared state to all its child components through MyContext.Provider.
The ParentComponent acts as an intermediary and simply renders the ChildComponent.
The ChildComponent receives the shared state using useContext and displays the message, count, and a button. Clicking the button invokes the incrementCount function, which updates the count value in the shared state of App.js.
This way, the shared state is accessible and can be updated by any component within the context, avoiding the need for prop drilling.
Optimizing React Apps
The useMemo Hook
The useMemo()is a pre-defined React hook that takes two arguments: a compute function that calculates a result and an array of dependencies.
const memoizedResult = useMemo(compute, dependencies);
The useMemo hook in React functional components returns a memoized value. 
Memoization is a concept used in computer science to save re-computation time by returning a cached result. In the context of React Hooks, you might be wondering what memoization means.
Memoization is the practice of avoiding re-computing a function with the same argument multiple times by caching the result and returning it for subsequent calls. This helps save computation time and resources.
The useMemo(compute, dependencies) hook calculates and memoizes the result during the initial rendering, and returns it to the component. If the dependencies remain the same during the subsequent renderings, the hook returns the memoized value without invoking the compute function. 
However, if the dependencies change, the hook invokes compute, memoizes the new value, and returns it. It is crucial to specify the state or props values used by the computation function as dependencies:
const memoizedResult = useMemo(() => {
  return expensiveFunction(propA, propB);
}, [propA, propB]);
An example will be examined to help comprehend the workings of useMemo().
Suppose we have a component called <CalculateFactorial />, which calculates the factorial of a number entered into an input field. Here is a sample implementation of the <CalculateFactorial /> component:
import { useState } from 'react';
export function CalculateFactorial() {
  const [number, setNumber] = useState(1);
  const [inc, setInc] = useState(0);
  const factorial = factorialOf(number);
  const onChange = event => {
    setNumber(Number(event.target.value));
  };
  const onClick = () => setInc(i => i + 1);
  
  return (
    <div>
      Factorial of 
      <input type="number" value={number} onChange={onChange} />
      is {factorial}
      <button onClick={onClick}>Re-render</button>
    </div>
  );
}
function factorialOf(n) {
  console.log('factorialOf(n) called!');
  return n <= 0 ? 1 : n * factorialOf(n - 1);
}
Whenever the input value is changed, the factorial is calculated using the factorialOf(n) function, and a message of 'factorialOf(n) called!' is logged to the console.
However, every time the Re-render button is clicked, the inc state value is updated, triggering a re-render of the <CalculateFactorial /> component. As a result, the factorial is recalculated again, and another message of 'factorialOf(n) called!' is logged to the console.
To improve the efficiency of the <CalculateFactorial /> component and memoize the factorial calculation, we can use the useMemo() hook.
Instead of simply invoking factorialOf(number) each time the component re-renders, we can use useMemo(() => factorialOf(number), [number]) to memoize the calculation result based on the value of the number variable.
This way, the calculation is only performed when the number variable changes, and the memoized result is returned for subsequent re-renders, improving the performance of the component:
import { useState, useMemo } from 'react';
export function CalculateFactorial() {
  const [number, setNumber] = useState(1);
  const [inc, setInc] = useState(0);
  const factorial = useMemo(() => factorialOf(number), [number]);
  const onChange = event => {
    setNumber(Number(event.target.value));
  };
  const onClick = () => setInc(i => i + 1);
  
  return (
    <div>
      Factorial of 
      <input type="number" value={number} onChange={onChange} />
      is {factorial}
      <button onClick={onClick}>Re-render</button>
    </div>
  );
}
function factorialOf(n) {
  console.log('factorialOf(n) called!');
  return n <= 0 ? 1 : n * factorialOf(n - 1);
}
When the input value is changed, the message 'factorialOf(n) called!'
 is logged to the console indicating that the factorial is being recalculated as expected.
However, when the "Re-render" button is clicked, the message isn't logged because useMemo(() => factorialOf(number), [number]) returns the memoized value of the factorial calculation, thus avoiding unnecessary recalculations.
The useCallback Hook
In React applications, optimizing performance involves minimizing unnecessary renders and reducing the time it takes for a render to update. To improve performance and avoid unnecessary renders, one approach is to use the useCallback() hook.
Functions equality
Before we explore the functionality of useCallback(), let's revisit the concept of referential and function equality.
In JavaScript, functions can be treated as variables and can be passed as arguments to other functions, returned by functions, assigned to variables, and compared with other variables. Essentially, functions can perform any task that an object can.
We will now create a function called sumFunctionFactory(), which will return another function that sums numbers. Then, we will use that function to create two functions called function1 and function2.
// factory function
function sumFunctionFactory() {
  return (a, b) => a + b;
}

const function1 = sumFunctionFactory();
const function2 = sumFunctionFactory();

function1(2, 3);
// expected output: 5
function2(2, 3);
// expected output: 5

console.log(function1 === function2);
// expected output: false
Although function1 and function2 have identical source code, they are two different function objects and therefore refer to distinct instances. As a result, comparing them using an equality operator will evaluate to false, which is just the way JavaScript works.
The useCallback Hook
When a React component is re-rendered, all the functions inside the component are re-created, resulting in a change in their references between renders.
The useCallback() hook provides a cached version of a callback function that will only be re-evaluated if its dependencies undergo changes. This allows us to reuse the same function object between renders, rather than creating a new one each time the component re-renders.
 
const memoized = useCallback(() => {
   // the callback function to be memoized
 },
  // dependencies array
[])
We can create an example to better understand how the useCallback() hook works in React. Let's create a parent component called "Notes" that has a state named "notes" which will contain all the notes, and a function named "addNote" that adds a random note whenever we click a button.
const Notes = () => {
 const [notes, setNotes] = useState([]);
 const addNote = () => {
   const newNote = "random";
   setNotes(n => [...n, newNote]);
 };
 return (
   <div>
   <h1>Button:</h1>
   {notes.map((note, index) => (
     <p key={index}>{note}</p>
   ))}
   </div>
 );
};
Let's proceed with creating our Button component, which will be a basic button with a prop named addNote. This prop will enable us to add a note every time we click the button. To keep track of the button's rendering, we have included a console.log statement inside the Button component. This statement will log every time the component is re-rendered.
const Button = ({ addNote }) => {
 console.log("Button re-rendered :( ");
 return (
   <div>
   <button onClick={addNote}>Add</button>
   </div>
 );
};
We can import our Button component and pass the addNote function as a prop to add a note successfully. However, we notice that the Button component re-renders every time, which is unnecessary because the only thing that changes in our app is the notes state, not the Button. 
To prevent this unnecessary re-render, we can use the useCallback hook. How can we implement the useCallback hook in this case to avoid the Button component from re-rendering unnecessarily?
To prevent the unnecessary re-rendering of the Button component, we can use the useCallback hook by wrapping the addNote function. As a dependency, we should pass the setNotes updater function because it is the only thing that affects the Button component's behavior.
const addNote = useCallback(() => {
 const newNote = "random";
 setNotes(n => [...n, newNote]);
}, [setNotes]);
Although we wrapped the addNote function with useCallback, we can still see the Button component re-rendering when we check the console. 
By default, React will re-render every component unless we use a mechanism to prevent this behavior. In our case, we can use the React.memo function to prevent the Button component from re-rendering unless its props, specifically the addNote prop, have changed.
By using React.memo(), a higher-order component, we can wrap components that we want to prevent from re-rendering, unless their props are updated.
Since we are using the useCallback hook to wrap the addNote function, it will never change. Therefore, our Button component will not re-render unnecessarily. Here is how our updated Button component will appear:
const Button = React.memo(({ addNote }) => {
 console.log("Button re-rendered :( ");
return (
   <div>
   <button onClick={addNote}>Add</button>
   </div>
 );
});
We now have an efficient and high-performing component that avoids unnecessary re-renders. Although the useCallback hook is relatively straightforward, it is essential to use it appropriately and in the right places; otherwise, it won't have any positive impact on performance.
Difference Between useMemo And useCallback
Both useMemo and useCallback hooks require a function and an array of dependencies. The primary distinction between the two is that useCallback caches the value returned by the function, while useMemo caches the function itself. In other words, the difference lies in what is cached: a value or a function.
Suppose you have a computationally expensive code that takes arguments and returns a value. In that case, you should use useMemo to maintain a reference to the value between renders without re-executing the computationally expensive code.
Conversely, if you need to maintain a persistent function instance for multiple renders, you should use useCallback. This is analogous to declaring a function outside of the scope of your React component to preserve it.
Project Implementation Step 2
App.js
import React, { useState, useMemo, useCallback } from 'react';
import UserList from './components/UserList';
import Filter from './components/Filter';

const App = () => {
  const [users, setUsers] = useState([
    { id: 1, name: 'John', active: true },
    { id: 2, name: 'Jane', active: false },
    { id: 3, name: 'Mike', active: true },
  ]);
  const [filter, setFilter] = useState('all');

  const filteredUsers = useMemo(() => {
    if (filter === 'active') {
      return users.filter((user) => user.active);
    } else if (filter === 'inactive') {
      return users.filter((user) => !user.active);
    } else {
      return users;
    }
  }, [users, filter]);

  const handleFilterChange = useCallback((event) => {
    setFilter(event.target.value);
  }, []);

  return (
    <div>
      <h1>User Filter App</h1>
      <Filter handleFilterChange={handleFilterChange} />
      <UserList users={filteredUsers} />
    </div>
  );
};

export default App;
UserList.js
import React from 'react';

const UserList = ({ users }) => {
  return (
    <div>
      <h2>User List</h2>
      <ul>
        {users.map((user) => (
          <li key={user.id}>{user.name}</li>
        ))}
      </ul>
    </div>
  );
};

export default UserList;
Filter.js
import React from 'react';

const Filter = ({ handleFilterChange }) => {
  return (
    <div>
      <h2>Filter</h2>
      <label>
        <input
          type="radio"
          name="filter"
          value="all"
          onChange={handleFilterChange}
        />
        All
      </label>
      <label>
        <input
          type="radio"
          name="filter"
          value="active"
          onChange={handleFilterChange}
        />
        Active
      </label>
      <label>
        <input
          type="radio"
          name="filter"
          value="inactive"
          onChange={handleFilterChange}
        />
        Inactive
      </label>
    </div>
  );
};

export default Filter;
Output:
notion image
notion image
notion image
Explanation: 
Let's go through the working of all three components:
App Component:
The App component is the main component of our application. It maintains the state for the list of users and the filter value. It renders the Filter component and the UserList component.
The users state is an array of user objects, each containing an id, name, and active property. The filter state represents the currently selected filter option.
The filteredUsers variable is computed using the useMemo hook. It calculates the filtered list of users based on the current filter value and the users array. It will only recalculate when the users or filter dependencies change.
The handleFilterChange function is defined using the useCallback hook. It updates the filter state based on the selected filter option. The function is memoized and will remain the same across renders unless the dependencies change.
Filter Component:
The Filter component receives the handleFilterChange function as a prop. It displays three radio buttons for filtering options: All, Active, and Inactive. Each radio button has an onChange event handler that calls the handleFilterChange function.
When a user selects a filter option, the corresponding radio button triggers the onChange event. The handleFilterChange function updates the filter state with the new value.
UserList Component:
The UserList component receives the users prop, which represents the filtered list of users to be displayed. It renders a list of user names based on the received prop.
For each user in the users array, the UserList component generates a list item with a unique key attribute based on the user's id. It then displays the user's name.
Whenever the users prop changes, the UserList component will update accordingly and render the updated list of user names.
Overall, the App component manages the state and passes it down to the child components (Filter and UserList). The Filter component allows the user to select a filter option, and the UserList component displays the filtered list of users based on the selected option. By using the useMemo and useCallback hooks, unnecessary recalculations and re-renders are avoided, resulting in optimized performance.
 
Throttling and Debouncing Event Action in JavaScript
Debouncing
Before delving deeper into debouncing, let's examine a straightforward example of implementing a search box that enables users to search for something without having to click a button.
function App() {

  const handleChange = e => {
    console.log('api call...')
  }

  return (
    <div className="App">
      <header className="App-header">
        <p> Search  </p>
        <input type='text' onChange={handleChange} />
      </header>
    </div>
  );
}
The problem is that handleChange is computationally expensive, which can be problematic for the server as it will receive numerous HTTP requests simultaneously.
notion image
To address this issue, we can utilize a debounce function. 
A debounce function is invoked only after a specific interval of time has elapsed since its previous invocation.
function debounce(fn, delay) {
    let timer
    return function (...args) {
      clearTimeout(timer)
      timer = setTimeout(()=>fn(...args), delay)
    }
}
The concept is to create a higher-order function named "debounce," which receives a callback function and a delay in milliseconds as parameters and returns a new function that sets a timer to execute the callback after the specified delay.
The key here is that each invocation from the debounce function's returned function will invalidate the previous timer using clearTimeout(timer) and create a new timer.
Using the debounce function, we can ensure that the callback function is invoked only once after the delay from the last call.
<div className="App">
    <header className="App-header">
        <p> Search  </p>
        <input type='text' onChange={debounce(handleChange, 500)} />
    </header>
</div>
Result:
notion image
Throttling
Suppose that there is an event listener in our application that monitors the movement of the user's mouse and sends this data to a backend server to perform some operations based on the mouse's location.
const handleMouseMove = e => {
      //everytime the mouse moved this function will be invoked
      console.log('api call to do some operations...')
  }
 //event listener to track the movement of the mouse
window.addEventListener('mousemove',handleMouseMove)
Using this solution will overload the backend server with many requests in a short time, which can cause it to become unresponsive or slow.
notion image
1600 API calls in few seconds are very, very bad ðŸ“›ðŸ“›ðŸ“›.
We can employ a throttle function to restrict the frequency of API calls.
This mechanism restricts the frequency of calls to a function within a particular time interval, ignoring any additional calls made during that time.
function throttle(fn, delay) {
    let run = false
    return function (...args) {
      if (!run) {
        fn(...args)
        run = true
        setTimeout( () => run = false, delay)
      }
    }
  }
A throttle function takes two arguments: fn, which is the function to be throttled, and delay in milliseconds which represents the throttling interval. The function then returns a throttled function.
const handleMouseMove = e => {
      //everytime the mouse moved this function will be invoked
      console.log('api call to do some operations...')
  }

  //event listener to track the movement of the mouse
  window.addEventListener('mousemove', throttle(handleMouseMove, 1000))
//1000ms => 1 second
Result:
notion image
Avoid using Index as Key for map
It's common to use indexes as keys when rendering a list.
{
    comments.map((comment, index) => {
        <Comment 
            {..comment}
            key={index} />
    })
}
It is common to use indexes as keys when rendering a list, but this can result in inaccurate data being displayed since the key is used to identify DOM elements. If an item is pushed or removed from the list and the key remains the same, React assumes that the DOM element represents the same component.
It is best practice to use a unique property as the key. If the data has no unique attributes, you can consider using the shortid module, which generates a unique key.
import shortid from  "shortid";
{
    comments.map((comment, index) => {
        <Comment 
            {..comment}
            key={shortid.generate()} />
    })
}
Using a unique property, such as an ID, from the data to set as the key is a better approach.
{
    comments.map((comment, index) => {
        <Comment 
            {..comment}
            key={comment.id} />
    })
}
The index used as the key is acceptable in some cases, but only under specific conditions:
The list and its items are static and never change
The items in the list do not have unique IDs, and the list is never reordered or filtered
The list is immutable and will not be modified during the component's lifecycle.
Code Splitting using React.Lazy & Suspense
To ensure optimal performance of your JavaScript, you need to balance the size of your dependencies with the amount of code your project has. As the amount of code increases, the browser will take longer to load it. To achieve this balance, you can use a technique called code splitting.
What is code splitting?
Client Side Rendering (CSR)
Client Side Rendering (CSR)
Many JavaScript frameworks bundle all their dependencies into a single large file, making adding JavaScript to an HTML web page easy. This approach reduces the number of calls needed to set up the page, since all the JavaScript is in one place. 
Theoretically, bundling JavaScript should speed up page loads and reduce the amount of traffic the page needs to handle.
However, as the bundle grows larger, the overhead of interpreting and executing the code may slow down page load times instead of speeding them up. 
The critical point at which this occurs varies for each page, and it's important to test your pages to determine where this point is. There are no general guidelines, as it depends on the specific dependencies being loaded.
To optimize page performance, it's important to identify which parts of a page require different JavaScript dependencies. Code splitting enables developers to remove certain dependencies from bundles and load them only where they are required. 
This improves page performance significantly because instead of loading all the JavaScript simultaneously, it's loaded in multiple chunks.
Code splitting is especially useful for large React applications where speed is crucial to user experience. 
Studies have shown that users form an impression of a page within three seconds, so even small improvements in page load time can have a significant impact. As a result, it's ideal to aim for a load time of three seconds or less.
Dynamic imports
Using dynamic "import" syntax is one of the easiest ways to split code in React. While some bundlers can parse it natively, others require configuration. This method is suitable for both server-side rendering and static site generation.
With dynamic imports, the "then" function imports only the necessary code. Any calls to imported code must be inside this function.
import("./parseText").then(parseText => {
  console.log(parseText.count("This is a text string", "text"));
});
By splitting the single bundle into multiple separate chunks, we can improve the performance of our application. One chunk can contain the code for the initial route, while other chunks can contain the unused code. 
We can use dynamic imports to lazy load a secondary chunk only when it's needed.
We can use the React to make use of lazy loading in React.lazy function. This function allows us to dynamically import a dependency and render it as a component in just one line of code. 
However, we need to ensure that the Lazy component is rendered inside the Suspense component, which helps to show fallback content while the lazy component is loading.
import React, { Suspense } from 'react';
const LazyComponent = React.lazy(() => import('./LazyComponent'));
function MyComponent() {
  return (
    <div>
      <Suspense fallback={<div>Loading...</div>}>
        <LazyComponent />
      </Suspense>
    </div>
  );
}
You can specify the fallback content for Suspense using the fallback prop, which can take any React element. You can position the Suspense component above the lazy component in any location, and it is also possible to enclose multiple lazy components with a single Suspense component.
import React, { Suspense } from 'react';
const ComponentOne = React.lazy(() => import('./ComponentOne'));
const ComponentTwo = React.lazy(() => import('./ComponentTwo'));
function MyComponent() {
   return (
      <div>
        <Suspense fallback={<div>Loading...</div>}>
         <ComponentOne />
         <ComponentTwo />
        <Suspense>
      </div>
   );
}
Route-based code splitting:
Implementing code-splitting in a codebase can be challenging, but splitting the bundles evenly can enhance the user experience.
import React from 'react';
import Suspense from 'react';
import lazy from 'react';
import {Route, Switch, BrowserRouter } from 'react-router-dom';
const HomeComponent = lazy(() => import('./routes/HomeComponent'));
const BlogComponent = lazy(() => import('./routes/BlogComponent'));
const App = () => (
  <Suspense fallback={<div>Loading...</div>}>
    <BrowserRouter> 
      <Switch>
         <Route path={"/home"}>
            <HomeComponent />
         </Route>
         <Route path={"/blog"}>
            <BlogComponent />
         </Route>
         <Route path="/">
            <Redirect to={"/home"} />
         </Route>
      </Switch> 
    </BrowserRouter>
  <Suspense/>
This module covered local state, props drilling, Context API for state management, and optimization techniques in React, while the next module will focus on using Redux for global state management.
Project Implementation Step 3
App.js
import "./styles.css";
import Navbar from "./component/Navbar"
import React, { lazy, Suspense } from 'react';

const Home = lazy(() => import('./component/Home'));

const App = () => {
  return (
    <div>
      <NavBar/>
      <Suspense fallback={<div>Loading...</div>}>
        <Home />
      </Suspense>
    </div>
  );
};

export default App;
Navbar.js
import React from "react";
import { NavLink } from "react-router-dom";
import { useSelector } from "react-redux";
import { FaSignInAlt, FaUserPlus, FaShoppingCart } from "react-icons/fa";

const Navbar = () => {
  const state = useSelector((state) => state.handleCart);
  return (
    <div>
      <nav className="navbar navbar-expand-lg navbar-light bg-white py-3 shadow-sm">
        <div className="container">
          <NavLink className="navbar-brand fw-bold fs-4" to="/">
            LA COLLECTION
          </NavLink>
          <button
            className="navbar-toggler"
            type="button"
            data-bs-toggle="collapse"
            data-bs-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent"
            aria-expanded="false"
            aria-label="Toggle navigation"
          >
            <span className="navbar-toggler-icon"></span>
          </button>
          <div className="collapse navbar-collapse" id="navbarSupportedContent">
            <ul className="navbar-nav mx-auto mb-2 mb-lg-0">
              <li className="nav-item">
                <NavLink className="nav-link active" aria-current="page" to="/">
                  Home
                </NavLink>
              </li>
              <li className="nav-item">
                <NavLink className="nav-link" to="/products">
                  Products
                </NavLink>
              </li>
              <li className="nav-item">
                <NavLink className="nav-link" to="/about">
                  About
                </NavLink>
              </li>
              <li className="nav-item">
                <NavLink className="nav-link" to="/contact">
                  Contact
                </NavLink>
              </li>
            </ul>
            <div className="buttons">
              <NavLink to="/login" className="btn btn-outline-dark">
                <FaSignInAlt className="me-1" /> Login
              </NavLink>
              <NavLink to="/register" className="btn btn-outline-dark ms-2">
                <FaUserPlus className="me-1" /> Register
              </NavLink>
              <NavLink to="/cart" className="btn btn-outline-dark ms-2">
                <FaShoppingCart className="me-1" /> Cart ({state.length})
              </NavLink>
            </div>
          </div>
        </div>
      </nav>
    </div>
  );
};

export default Navbar;
Home.js
import React from "react";
import Products from "./products";
import img from '../assets/bg.jpg'

const Home = () => {
  return (
    <div className="hero">
      <div className="card bg-dark text-white border-0">
        <img
          src={img}
          className="card-img"
          alt="Background"
          height="550px"
        />
        <div className="card-img-overlay d-flex flex-column justify-content-center">
          <div className="container">
            <h5 data-testid='home'  className="card-title display-3 fw-bolder mb-0">
              NEW SEASON ARRIVALS
            </h5>
            <p className="card-text lead fs-2">CHECK OUT ALL THE TRENDS</p>
          </div>
        </div>
      </div>
      <Products />
    </div>
  );
};

export default Home;
Output:
notion image
notion image
Explanation:
In the above given code, Code Splitting is implemented using the React.lazy function and the Suspense component. Code Splitting is a technique used to split the JavaScript code into smaller chunks and load them on demand, instead of loading the entire bundle upfront. This can help improve performance by reducing the initial load time of the application.
Here's how Code Splitting is implemented in the code:
The lazy function from React is used to wrap the dynamic import of the Home component. The lazy function allows for the lazy loading of the component, meaning it will be loaded only when it is actually needed.
The Suspense component is used to wrap the component that is being lazily loaded (Home component in this case). The Suspense component enables the rendering of a fallback UI while the lazily loaded component is loading.
Inside the Suspense component, a fallback UI is defined using the fallback prop. In this case, a simple <div>Loading...</div> is used as the fallback UI.
By using React.lazy and Suspense, the Home component is dynamically loaded only when it is actually rendered in the application. The rest of the code and components in the App component are loaded immediately.
When the Home component is lazily loaded, the Suspense component will display the fallback UI (in this case, "Loading...") until the Home component is fully loaded and ready to be rendered. Once the Home component is loaded, it will be rendered in place of the fallback UI.
This way, Code Splitting with React.lazy and Suspense allows for better performance by splitting the code into smaller chunks and loading them on demand, improving the initial loading time of the application.
 
Summary
What did we learn?
Understanding the local state allows you to manage and update data within a specific component without needing external state management solutions. You learn how to initialize and update state using the useState hook, enabling you to handle component-specific data changes efficiently.
Recognizing the limitations of passing props through multiple layers of components, you explore the concept of props drilling. You understand how excessive prop passing can lead to code maintenance challenges and reduced reusability.
Resolving prop drilling issues, you discover the Context API, a built-in React feature that enables you to share state across components without explicitly passing props. You learn about createContext, Provider, Consumer, and the useContext hook, which collectively allow you to create and access shared state in a more elegant and efficient manner.
You delve into optimizing React applications using hooks such as useMemo and useCallback. By using useMemo, you can memoize the result of a computation, preventing unnecessary recalculations and improving performance. useCallback allows you to memoize event handler functions, avoiding unnecessary re-creations of functions and optimizing component rendering.
Debouncing and throttling help you control the rate at which an action is invoked. Debouncing ensures that the action is triggered only after a specified delay since the last invocation while throttling limits the action to be invoked at a certain maximum rate.
You learn about the importance of using unique and stable keys when rendering dynamic lists in React. Understanding why using the index as a key is discouraged helps you build more robust and maintainable applications, avoiding potential issues when updating, reordering, or deleting list items.
By implementing code splitting, you discover techniques to optimize your application's initial load time. React.Lazy and Suspense allow you to dynamically load components and other resources, such as data or stylesheets, when they are needed, reducing the initial bundle size and improving performance.
Shortcomings & Challenges
State management can introduce complexity, especially when dealing with large-scale applications. Managing state flow across components and ensuring synchronization can become challenging and may require a thorough understanding of state management concepts and libraries.
Improper state management practices can lead to performance issues. For example, excessive re-rendering of components due to poorly optimized state updates or unnecessary prop drilling can impact application performance.
Debugging can become more complex when using advanced state management solutions. Tracking the flow of state changes, identifying the source of bugs, and understanding the state at different points in time may require additional debugging tools or techniques.
Some state management solutions may not seamlessly integrate with certain third-party libraries or frameworks. This can require additional effort or workarounds to ensure compatibility.
Best Practices
Identify the critical state that must be shared and managed across multiple components. Keep the rest of the state local to individual components to minimize unnecessary re-renders and make your code easier to reason about.
For forms and user input, use controlled components where the component's state reflects the current value of the input element. This ensures that the React component is the single source of truth for the input's state.
Optimize performance by preventing unnecessary re-renders. Use techniques like React.memo or shouldComponentUpdate (for class components) to prevent re-rendering when props or states haven't changed.
Avoid directly mutating states or props. Instead, use immutable data structures (e.g., by using libraries like Immutable.js or Immer) to create copies of the state and modify them in an immutable way. This helps prevent accidental state mutations and enables efficient change detection.
 
Enhance Your Knowledge
Supercharge your knowledge by exploring the resources provided! ðŸ“š
Lifting State Up Lifting State up in ReactJS - GeeksforGeeks
Optimizing Performance of React App: https://blog.logrocket.com/optimizing-performance-react-app/
 
Try it Yourself
Let's solve these coding problems in the AlmaBetter IDE. Don't forget to join the AlmaBetter Community Platform to share your brilliant approaches and cheer each other on! ðŸš€ Happy coding! ðŸ’»ðŸ˜„
Task 1: Want to showcase your frontend coding skills? Solve these problems seamlessly in the VS Code IDE.
Problem
Create a simple To-Do List application using React. The app should allow users to add and remove tasks dynamically.
Requirements:
Display an input field and a button to add new tasks.
When the user enters a task in the input field and clicks the "Add" button, the task should be added to the list of tasks.
Each task should have a "Delete" button next to it that, when clicked, removes the task from the list.
Use React state to manage the list of tasks.
Feel free to style the application as you like to make it visually appealing.
Expected Output
Hints:
Utilize the map function to iterate through the list of tasks and display them.
Make sure to assign unique keys to each task when rendering using the map function.
Implement a state variable to store the list of tasks and update it as tasks are added or removed.
Solution
// TodoList.js

import React, { useState } from 'react';
import './TodoList.css';

const TodoList = () => {
  const [tasks, setTasks] = useState([]);
  const [newTask, setNewTask] = useState('');

  const handleAddTask = () => {
    if (newTask.trim() !== '') {
      setTasks([...tasks, newTask]);
      setNewTask('');
    }
  };

  const handleDeleteTask = (index) => {
    const updatedTasks = tasks.filter((_, i) => i !== index);
    setTasks(updatedTasks);
  };

  return (
    <div className="todo-list">
      <h2>My To-Do List</h2>
      <ul>
        {tasks.map((task, index) => (
          <li key={index}>
            <input type="checkbox" /> {task} <button onClick={() => handleDeleteTask(index)}>Delete</button>
          </li>
        ))}
      </ul>
      <div className="add-task">
        <input
          type="text"
          value={newTask}
          onChange={(e) => setNewTask(e.target.value)}
          placeholder="Add a new task"
        />
        <button onClick={handleAddTask}>Add</button>
      </div>
    </div>
  );
};

export default TodoList;
/* TodoList.css */

.todo-list {
  width: 300px;
  margin: 0 auto;
}

ul {
  list-style-type: none;
  padding: 0;
}

li {
  margin: 8px 0;
}

input[type="checkbox"] {
  margin-right: 8px;
}

.add-task input[type="text"] {
  margin-right: 8px;
}

.add-task button {
  background-color: #4caf50;
  color: white;
  padding: 6px 10px;
  border: none;
  cursor: pointer;
}
// App.js

import React from 'react';
import TodoList from './TodoList';

function App() {
  return (
    <div className="App">
      <TodoList />
    </div>
  );
}

export default App;
Task 2: How did you ensure code modularity? Share your approach with other Cohorts on AlmaBetter's Community platform.
